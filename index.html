<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- ƒê·ªïi t√™n title --><title>Green Energy Game</title>
    <!-- T·∫£i Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ƒê·∫£m b·∫£o chi·ªÅu cao ƒë·∫ßy ƒë·ªß */
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Tr√°nh cu·ªôn trang */
        }
        
        #game-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            /* TH√äM M·ªöI: B·ªë c·ª•c c·ªôt cho mobile, b·ªë c·ª•c h√†ng cho desktop */
            flex-direction: column;
        }
        @media (min-width: 768px) { /* md breakpoint */
             #game-container {
                flex-direction: row;
             }
        }

        /* M√†n h√¨nh A (Khu v·ª±c m√¥ h√¨nh) */
        #model-a {
            /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc cho mobile v√† desktop */
            width: 100%;
            height: 60%; /* 60% chi·ªÅu cao tr√™n mobile */
            background-color: #D1D5DB; /* Gray-500 (X√°m ƒë·∫≠m m·∫∑c ƒë·ªãnh - Khi ch∆∞a c√≥ m·∫∑t tr·ªùi) */
            background-size: cover;
            background-position: center;
            position: relative; /* Quan tr·ªçng ƒë·ªÉ ƒë·ªãnh v·ªã c√°c item con */
            transition: background-color 0.5s ease;
        }
        @media (min-width: 768px) { /* md breakpoint */
             #model-a {
                width: 80%; /* w-4/5 */
                height: 100%; /* h-full */
             }
        }
        
        /* C·∫¨P NH·∫¨T: N·ªÅn xanh l√° khi c√≥ m·∫∑t tr·ªùi v√† kh√¥ng b·ªã che */
        #model-a.sun-present-bg {
            background-color: #D1FAE5; /* Green-100 (Xanh l√° s√°ng) */
        }
        
        /* TH√äM M·ªöI: N·ªÅn khi m·∫∑t tr·ªùi b·ªã m√¢y che */
        #model-a.sky-partly-cloudy {
             background-color: #A3E6B4; /* Xanh l√° nh·∫°t pha x√°m (t√πy ch·ªânh) */
        }


        /* L·ªõp SVG ƒë·ªÉ v·∫Ω d√¢y d·∫´n (N·∫±m d∆∞·ªõi c√°c c√¥ng c·ª•) */
        #wire-svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10; /* N·∫±m d∆∞·ªõi c√°c c√¥ng c·ª• (z-index 20) */
            pointer-events: none; /* Cho ph√©p click xuy√™n qua */
        }
        
        /* D√¢y t·∫°m th·ªùi khi ƒëang k√©o */
        #temp-wire {
            stroke: #FDE047; /* V√†ng s√°ng */
            stroke-width: 4;
            stroke-dasharray: 8, 8;
            fill: none;
        }
        
        /* D√¢y vƒ©nh vi·ªÖn sau khi th·∫£ */
        .permanent-wire {
            stroke: #22C55E; /* Green-500 (M√†u xanh l√°) */
            stroke-width: 5;
            fill: none;
            stroke-linecap: round;
            pointer-events: none;
        }
        
        /* CSS CHO HI·ªÜU ·ª®NG D√ÇY D·∫™N "HO·∫†T ƒê·ªòNG" (N√âT ƒê·ª®T CH·∫†Y) */
        @keyframes flow-animation {
            from { stroke-dashoffset: 0; }
            to { stroke-dashoffset: 20; } /* ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô ch·∫°y */
        }
        
        /* M√†u v√†ng cam m·∫∑c ƒë·ªãnh cho d√¢y active (ngu·ªìn) */
        .permanent-wire.wire-active {
            stroke: #F59E0B; /* M√†u v√†ng cam */
            stroke-dasharray: 10, 10; /* N√©t ƒë·ª©t */
            /* Animation m·∫∑c ƒë·ªãnh ch·∫°y t·ª´ END v·ªÅ START */
            animation: flow-animation 1s linear infinite;
        }
        
        /* C·∫¨P NH·∫¨T: M√†u ƒë·ªè cho d√¢y ƒë√®n active */
        .permanent-wire.light-wire-active {
             stroke: #EF4444; /* Red-500 */
        }
        
        /* ƒê·∫£o ng∆∞·ª£c h∆∞·ªõng ch·∫°y (th√†nh START v·ªÅ END) */
        .permanent-wire.wire-active.wire-reversed {
            animation-direction: reverse;
        }
        
        /* M√†n h√¨nh B (H·ªôp c√¥ng c·ª•) */
        #tools-b {
            /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc cho mobile v√† desktop */
            width: 100%;
            height: 40%; /* 40% chi·ªÅu cao tr√™n mobile */
            background-color: #78350F; /* M√†u g·ªó t·ªëi (yellow-800) */
            border-top: 8px solid #451A03; /* ƒê·ªïi vi·ªÅn sang top */
            border-left: none; /* X√≥a vi·ªÅn tr√°i */
            box-shadow: 0 -10px 20px rgba(0,0,0,0.3) inset; /* ƒê·ªïi b√≥ng l√™n tr√™n */
            /* C·∫¨P NH·∫¨T: Cho ph√©p cu·ªôn y */
            overflow-y: auto;
            padding: 1rem; /* p-4 */
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr)); /* grid-cols-2 */
            gap: 1rem; /* gap-4 */
        }
        @media (min-width: 768px) { /* md breakpoint */
             #tools-b {
                width: 20%; /* w-1/5 */
                height: 100%; /* h-full */
                border-left: 8px solid #451A03; /* Tr·∫£ l·∫°i vi·ªÅn tr√°i */
                border-top: none; /* X√≥a vi·ªÅn tr√™n */
                box-shadow: -10px 0 20px rgba(0,0,0,0.3) inset; /* Tr·∫£ l·∫°i b√≥ng b√™n tr√°i */
             }
        }

        /* √î ch·ª©a c√¥ng c·ª• */
        .tool-cell {
            background-color: #92400E; /* M√†u g·ªó s√°ng h∆°n (yellow-700) */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2) inset;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* C·∫ßn cho d·∫•u c·∫•m */
        }
        
        /* CSS cho ch·∫ø ƒë·ªô D√¢y d·∫´n */
        body.wiring-mode {
            cursor: crosshair; /* H√¨nh d·∫•u + */
        }

        /* √î c√¥ng c·ª• khi ƒë∆∞·ª£c ch·ªçn (D√¢y d·∫´n) */
        .tool-cell.active-tool {
            background-color: #34D399; /* Green-400 */
            box-shadow: 0 0 15px #10B981 inset; /* Hi·ªáu ·ª©ng ph√°t s√°ng */
        }

        /* C√¥ng c·ª• (trong h·ªôp) */
        .tool-item {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            transition: transform 0.2s ease;
            font-size: 50px; /* K√≠ch th∆∞·ªõc cho Emoji */
            position: relative; /* C·∫ßn cho d·∫•u c·∫•m */
        }
        
        .tool-item:hover {
            transform: scale(1.1);
        }
        
        .tool-item .svg-icon {
            width: 100%;
            height: 100%;
        }

        /* TH√äM M·ªöI: D·∫•u c·∫•m cho c√¥ng c·ª• ƒë√£ d√πng */
        .tool-item.tool-prohibited {
            cursor: not-allowed; /* ƒê·ªïi con tr·ªè */
            opacity: 0.6; /* L√†m m·ªù ƒëi */
        }
        .tool-item.tool-prohibited::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            width: 20px;
            height: 20px;
            background-color: #EF4444; /* Red-500 */
            border-radius: 50%;
            border: 2px solid white;
            z-index: 1; /* N·∫±m tr√™n c√¥ng c·ª• */
        }
         .tool-item.tool-prohibited::after {
            content: '';
            position: absolute;
            top: 13px; /* ƒêi·ªÅu ch·ªânh v·ªã tr√≠ g·∫°ch ch√©o */
            left: 7px;
            width: 16px;
            height: 4px; /* ƒê·ªô d√†y g·∫°ch ch√©o */
            background-color: white;
            transform: rotate(45deg);
            z-index: 2; /* N·∫±m tr√™n v√≤ng tr√≤n */
        }


        /* C√¥ng c·ª• ƒë√£ ƒë∆∞·ª£c th·∫£ (tr√™n m√†n h√¨nh A) */
        .cloned-item {
            position: absolute;
            z-index: 20;
            /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc c∆° s·ªü responsive */
            width: 60px; 
            height: 60px;
            font-size: 38px; /* Gi·∫£m c·ª° emoji 1 ch√∫t */
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Th√™m transition ƒë·ªÉ di chuy·ªÉn m∆∞·ª£t m√† khi "snap" */
            transition: left 0.3s ease, top 0.3s ease;
        }
         @media (min-width: 768px) { /* md breakpoint */
            .cloned-item {
                 width: 80px;
                 height: 80px;
                 font-size: 50px;
            }
         }
        
        .cloned-item .svg-icon {
            width: 100%;
            height: 100%;
        }
        
        .cloned-item:active {
            cursor: grabbing;
            transition: none; /* T·∫Øt transition khi ƒëang k√©o */
        }

        /* Tr·∫°ng th√°i khi ƒëang k√©o (c·∫£ b·∫£n sao v√† b·∫£n g·ªëc) */
        .dragging {
            position: absolute; /* Ph·∫£i l√† absolute ƒë·ªÉ di chuy·ªÉn t·ª± do */
            z-index: 1000; /* Lu√¥n n·ªïi l√™n tr√™n c√πng */
            pointer-events: none; /* Kh√¥ng c·∫£n tr·ªü s·ª± ki·ªán mouseup */
            opacity: 0.9;
            transition: none; /* T·∫Øt transition khi ƒëang k√©o */
        }

        /* CSS CHO ANIMATION QUAY */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* ƒê·∫∑t t√¢m quay cho c√°c c√°nh qu·∫°t (d·ª±a tr√™n viewBox 100x100, t√¢m ·ªü 50, 35) */
        .turbine-blades {
            transform-origin: 50% 35%;
        }

        /* √Åp d·ª•ng animation khi item c√≥ class 'spinning' */
        .cloned-item.spinning .turbine-blades {
            animation: spin 2s linear infinite;
        }
        
        /* === CSS PIN M·∫∂T TR·ªúI === */
        
        /* Ki·ªÉu cell pin m·∫∑t tr·ªùi (m√†u xanh d∆∞∆°ng ƒë·∫≠m) */
        .solar-cell {
            fill: #1E3A8A; /* blue-900 (Xanh d∆∞∆°ng ƒë·∫≠m) */
            transition: fill 0.2s ease;
        }

        /* Animation nh·∫•p nh√°y V√†ng <-> Xanh */
        @keyframes solar-blink {
            0%, 100% { fill: #1E3A8A; } /* Xanh d∆∞∆°ng ƒë·∫≠m */
            50% { fill: #F59E0B; }      /* V√†ng cam (gi·ªëng m√†u d√¢y) */
        }

        /* Khi m·∫∑t tr·ªùi active, √°p d·ª•ng animation cho c√°c cell */
        .cloned-item.solar-active .solar-cell {
            /* step-end gi√∫p animation "nh·∫£y" m√†u, kh√¥ng b·ªã m·ªù */
            animation: solar-blink 1s infinite step-end;
        }

        /* T·∫°o hi·ªáu ·ª©ng "t·ª± do" (nh·∫•p nh√°y ng·∫´u nhi√™n) b·∫±ng c√°ch delay kh√°c nhau */
        .cloned-item.solar-active .solar-cell:nth-child(3n+1) {
            animation-delay: -0.2s;
        }
        .cloned-item.solar-active .solar-cell:nth-child(3n+2) {
            animation-delay: -0.5s;
        }
        .cloned-item.solar-active .solar-cell:nth-child(3n+3) {
            animation-delay: -0.8s;
        }

        /* === CSS B√ìNG ƒê√àN V√Ä C√îNG T·∫ÆC === */
        
        /* Ph·∫ßn th·ªßy tinh c·ªßa b√≥ng ƒë√®n (m·∫∑c ƒë·ªãnh m√†u x√°m) */
        .bulb-glass {
            fill: #6B7280; /* Gray-500 */
            transition: fill 0.3s ease;
        }
        
        /* Khi ƒë√®n b·∫≠t, chuy·ªÉn m√†u v√†ng */
        .cloned-item.bulb-on .bulb-glass {
            fill: #FDE047; /* Yellow-300 */
            /* Th√™m hi·ªáu ·ª©ng ph√°t s√°ng nh·∫π */
            filter: drop-shadow(0 0 10px #FDE047);
        }

        /* C·∫ßn g·∫°t c√¥ng t·∫Øc (m·∫∑c ƒë·ªãnh T·∫ÆT - ƒê·ªè, V·ªã tr√≠ d∆∞·ªõi) */
        .switch-lever {
            fill: #EF4444; /* Red-500 */
            transition: fill 0.2s ease, y 0.2s ease;
            /* y="45" ƒë∆∞·ª£c ƒë·∫∑t trong SVG */
        }

        /* Khi c√¥ng t·∫Øc B·∫¨T (th√™m class .switch-on) */
        .cloned-item.switch-on .switch-lever {
            fill: #22C55E; /* Green-500 */
            /* Di chuy·ªÉn c·∫ßn g·∫°t l√™n tr√™n (thay ƒë·ªïi thu·ªôc t√≠nh y) */
            animation: switch-on-anim 0.2s forwards;
        }
        
        /* C·∫ßn animation ƒë·ªÉ thay ƒë·ªïi 'y' v√¨ n√≥ l√† thu·ªôc t√≠nh SVG, kh√¥ng ph·∫£i CSS */
        @keyframes switch-on-anim {
            from { y: 45; }
            to { y: 25; }
        }
        
        /* Ch·ªØ (c·∫£ ON v√† OFF) */
        .switch-text {
            font-size: 14px;
            font-weight: bold;
            font-family: Arial, sans-serif;
            text-anchor: middle;
            user-select: none; /* Kh√¥ng cho ph√©p ch·ªçn ch·ªØ */
        }

        /* Ch·ªØ OFF (ƒê·ªè, ·ªü tr√™n, m·∫∑c ƒë·ªãnh B·∫≠t) */
        .switch-text-off {
            fill: #EF4444;
            display: block;
        }

        /* Ch·ªØ ON (Xanh, ·ªü d∆∞·ªõi, m·∫∑c ƒë·ªãnh T·∫Øt) */
        .switch-text-on {
            fill: #22C55E;
            display: none;
        }

        /* Khi B·∫¨T, hi·ªán ch·ªØ ON, ·∫©n ch·ªØ OFF */
        .cloned-item.switch-on .switch-text-on {
            display: block;
        }
        .cloned-item.switch-on .switch-text-off {
            display: none;
        }

        /* B·∫£ng t√™n T·ªß ƒëi·ªán */
        .power-box-label {
            font-size: 8px; /* K√≠ch th∆∞·ªõc nh·ªè */
            font-weight: bold;
            font-family: Arial, sans-serif;
            fill: #FFFFFF; /* M√†u tr·∫Øng */
            text-anchor: middle;
            user-select: none;
        }
        
        /* C·∫¨P NH·∫¨T: AI Bot CSS (Di chuy·ªÉn sang ph·∫£i) */
        #ai-bot {
            position: absolute;
            bottom: 1rem; /* 20px */
            right: 1rem; /* 20px */
            left: auto; /* X√≥a v·ªã tr√≠ b√™n tr√°i */
            background-color: white;
            border-radius: 10px;
            padding: 10px 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            flex-wrap: wrap; /* Cho ph√©p xu·ªëng d√≤ng */
            align-items: center;
            /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc cho mobile v√† desktop */
            max-width: 280px;
            padding: 8px;
            z-index: 50; /* N·∫±m tr√™n c√°c item kh√°c */
        }
        @media (min-width: 768px) { /* md breakpoint */
            #ai-bot {
                max-width: 350px; /* TƒÉng chi·ªÅu r·ªông */
                padding: 10px 15px;
            }
        }

        #ai-bot img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 50%;
            object-fit: cover; /* ƒê·∫£m b·∫£o ·∫£nh v·ª´a v·∫∑n */
            flex-shrink: 0; /* Kh√¥ng co l·∫°i */
            /* C·∫¨P NH·∫¨T: ·∫®n avatar tr√™n mobile */
            display: none;
        }
        @media (min-width: 768px) { /* md breakpoint */
            #ai-bot img {
                display: block;
            }
        }

        #ai-explanation {
            /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc ch·ªØ v√† layout cho mobile */
            font-size: 13px;
            color: #374151; /* Gray-700 */
            margin: 0;
            flex-grow: 1; /* Chi·∫øm h·∫øt kh√¥ng gian c√≤n l·∫°i */
            margin-bottom: 8px; /* Kho·∫£ng c√°ch v·ªõi √¥ input */
            width: 100%; /* Chi·∫øm h·∫øt h√†ng tr√™n tr√™n mobile */
            min-height: 30px; /* ƒê·∫£m b·∫£o chi·ªÅu cao t·ªëi thi·ªÉu */
        }
        @media (min-width: 768px) { /* md breakpoint */
            #ai-explanation {
                font-size: 14px;
                width: calc(100% - 50px); /* Chi·∫øm g·∫ßn h·∫øt h√†ng tr√™n */
                min-height: 40px;
            }
        }
         /* TH√äM M·ªöI: Loading indicator */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin-loader 1s linear infinite;
            margin-left: 5px; /* Kho·∫£ng c√°ch v·ªõi text */
        }
        @keyframes spin-loader {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; } /* Helper class */

        #ai-input-row { /* Row cho input v√† button */
             display: flex;
             width: 100%;
             align-items: center;
             /* C·∫¨P NH·∫¨T: CƒÉn l·ªÅ cho mobile */
             margin-left: 0;
        }
         @media (min-width: 768px) { /* md breakpoint */
            #ai-input-row {
                 margin-left: 50px; /* CƒÉn l·ªÅ v·ªõi text */
            }
         }
        #ai-question {
            /* width: calc(100% - 70px); Chi·ªÅu r·ªông tr·ª´ ƒëi n√∫t G·ª≠i */
            flex-grow: 1; /* Chi·∫øm kh√¥ng gian c√≤n l·∫°i */
            padding: 5px 8px;
            border: 1px solid #D1D5DB; /* Gray-300 */
            border-radius: 5px;
            margin-right: 5px;
            font-size: 13px;
         }
         #ai-send-btn {
            padding: 5px 10px;
            background-color: #3B82F6; /* Blue-500 */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            flex-shrink: 0; /* Kh√¥ng co l·∫°i */
        }
         #ai-send-btn:hover {
             background-color: #2563EB; /* Blue-600 */
         }
         #ai-send-btn:disabled { /* Ki·ªÉu khi ƒëang t·∫£i */
             background-color: #9CA3AF; /* Gray-400 */
             cursor: not-allowed;
         }
         
        /* TH√äM M·ªöI: CSS cho Ti√™u ƒë·ªÅ v√† T√°c gi·∫£ */
        #game-title-container {
            position: absolute;
            top: 1rem; /* 16px */
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none; /* Cho ph√©p click xuy√™n qua */
            z-index: 30;
            color: #2563EB; /* Blue-600 */
            font-weight: bold;
        }
        .game-title {
            /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc ch·ªØ cho mobile */
            font-size: 1.2rem; /* 1.1rem * 2 = 35.2px */
            line-height: 1.5rem; /* ƒêi·ªÅu ch·ªânh line height */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .game-title {
                font-size: 2.2rem; 
                line-height: 2.5rem;
            }
        }

        .game-main-title {
             /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc ch·ªØ cho mobile */
            font-size: 2rem; 
            line-height: 2.2rem;
            color: #EF4444; /* Red-500 */
            margin-top: 5px;
        }
         @media (min-width: 768px) { /* md breakpoint */
            .game-main-title {
                font-size: 3.75rem; 
                line-height: 4rem;
            }
         }
        
        #author-credit-container {
            position: absolute;
            bottom: 1rem; /* 16px */
            /* C·∫¨P NH·∫¨T: V·ªã tr√≠ cho mobile v√† desktop */
            left: 1rem; /* 16px on mobile */
            transform: translateX(0); /* Reset transform on mobile */
            text-align: left; /* Align left on mobile */
            pointer-events: none; /* Cho ph√©p click xuy√™n qua */
            z-index: 30; /* N·∫±m tr√™n c√°c item kh√°c (ngo·∫°i tr·ª´ Bot) */
        }
         @media (min-width: 768px) { /* md breakpoint */
            #author-credit-container {
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
            }
         }

        .author-credit {
             /* C·∫¨P NH·∫¨T: K√≠ch th∆∞·ªõc ch·ªØ cho mobile */
            font-size: 1rem; 
            font-style: italic; /* Th√™m l·∫°i in nghi√™ng */
            color: #2563EB; /* ƒê·ªïi sang m√†u xanh d∆∞∆°ng (Blue-600) */
            font-weight: bold; /* Gi·ªØ in ƒë·∫≠m */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .author-credit {
                font-size: 1.75rem;
            }
         }


    </style>
</head>
<body class="bg-blue-100 h-screen w-screen">

    <div id="game-container">
        
        <!-- M√ÄN H√åNH A (M√î H√åNH) -->
        <div id="model-a" class="w-4/5 h-full">
            <!-- L·ªõp SVG ƒë·ªÉ v·∫Ω d√¢y d·∫´n --><svg id="wire-svg-layer"></svg>
            <!-- C√°c c√¥ng c·ª• ƒë∆∞·ª£c th·∫£ v√†o ƒë√¢y -->
            
            <!-- TH√äM M·ªöI: Ti√™u ƒë·ªÅ -->
            <div id="game-title-container">
                <p class="game-title">·ª¶y ban nh√¢n d√¢n x√£ T√¢n Th√†nh B√¨nh</p>
                <p class="game-title">Tr∆∞·ªùng Ti·ªÉu h·ªçc T√¢n Th√†nh B√¨nh 2</p>
                <p class="game-main-title">GREEN ENERGY HOUSE</p>
            </div>
            
            <!-- TH√äM M·ªöI: T√™n t√°c gi·∫£ -->
            <div id="author-credit-container">
                <p class="author-credit">T√°c gi·∫£: Nguy·ªÖn Th·ªã Thanh Quy√™n</p>
            </div>

            <!-- C·∫¨P NH·∫¨T: AI Bot v·ªõi Input v√† Button (ƒê√£ di chuy·ªÉn sang ph·∫£i) -->
            <div id="ai-bot">
                <img src="https://placehold.co/40x40/3B82F6/FFF?text=AI" alt="AI Bot Avatar">
                <p id="ai-explanation">Ch√†o m·ª´ng b·∫°n! H√£y th·ª≠ l·∫Øp m·∫°ch ƒëi·ªán nh√©.</p>
                <!-- Th√™m loading indicator -->
                <div id="ai-loader" class="loader hidden"></div>
                <div id="ai-input-row">
                     <input type="text" id="ai-question" placeholder="H·ªèi AI v·ªÅ nƒÉng l∆∞·ª£ng xanh...">
                     <button id="ai-send-btn">G·ª≠i</button>
                </div>
            </div>
        </div>

        <!-- M√ÄN H√åNH B (H·ªòP C√îNG C·ª§) --><div id="tools-b" class="w-1/5 h-full p-4 grid grid-cols-2 gap-4 overflow-y-auto">
            
            <!-- H√†ng 1 --><div class="tool-cell">
                <div class="tool-item" data-tool="sun" title="M·∫∑t tr·ªùi">‚òÄÔ∏è</div>
            </div>
            <div class="tool-cell">
                <!-- C√¥ng c·ª• 2: Ng√¥i nh√† (SVG) --><div class="tool-item" data-tool="house" title="Ng√¥i nh√†">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- M√°i nh√† (l·ªõn, m√†u ƒë·ªè) --><path d="M 5 40 L 50 10 L 95 40 Z" fill="#DC2626" stroke="#451A03" stroke-width="2"/>
                        <!-- Th√¢n nh√† (m√†u v√†ng) --><rect x="15" y="40" width="70" height="55" fill="#FBBF24" stroke="#451A03" stroke-width="2"/>
                        <!-- C·ª≠a --><rect id="house-door" x="40" y="60" width="20" height="35" fill="#78350F" stroke="#451A03" stroke-width="2"/>
                    </svg>
                </div>
            </div>

            <!-- H√†ng 2 --><div class="tool-cell">
                <!-- C√îNG C·ª§ 3: PIN M·∫∂T TR·ªúI (C·∫¨P NH·∫¨T) -->
                <div class="tool-item" data-tool="solar-panel" title="Pin m·∫∑t tr·ªùi">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <g transform="skewX(-20) translate(15 0)">
                            <!-- Khung ngo√†i (m√†u s·∫´m) -->
                            <rect x="10" y="25" width="70" height="50" fill="#064E3B" stroke="#064E3B" stroke-width="2" />
                            
                            <!-- L∆∞·ªõi 3x4 (12 cell) -->
                            <g>
                                <!-- H√†ng 1 -->
                                <rect class="solar-cell" x="10.5" y="25.5" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="33.6" y="25.5" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="56.9" y="25.5" width="22.6" height="11.75"/>
                                <!-- H√†ng 2 -->
                                <rect class="solar-cell" x="10.5" y="37.75" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="33.6" y="37.75" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="56.9" y="37.75" width="22.6" height="11.75"/>
                                <!-- H√†ng 3 -->
                                <rect class="solar-cell" x="10.5" y="50" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="33.6" y="50" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="56.9" y="50" width="22.6" height="11.75"/>
                                <!-- H√†ng 4 -->
                                <rect class="solar-cell" x="10.5" y="62.25" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="33.6" y="62.25" width="22.6" height="11.75"/>
                                <rect class="solar-cell" x="56.9" y="62.25" width="22.6" height="11.75"/>
                            </g>
                            
                            <!-- ƒê∆∞·ªùng k·∫ª l∆∞·ªõi m√†u tr·∫Øng -->
                            <g stroke="#FFF" stroke-width="0.75">
                                <!-- D·ªçc -->
                                <line x1="33.35" y1="25" x2="33.35" y2="75" />
                                <line x1="56.65" y1="25" x2="56.65" y2="75" />
                                <!-- Ngang -->
                                <line x1="10" y1="37.5" x2="80" y2="37.5" />
                                <line x1="10" y1="50" x2="80" y2="50" />
                                <line x1="10" y1="62.5" x2="80" y2="62.5" />
                            </g>
                        </g>
                    </svg>
                </div>
            </div>
            <!-- C·∫¨P NH·∫¨T: TUA-BIN 3 C√ÅNH QU·∫†T -->
            <div class="tool-cell">
                <div class="tool-item" data-tool="wind-turbine" title="Tua-bin gi√≥">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- Tr·ª• --><path d="M48 40 L48 95 Q 48 100 45 100 L 55 100 Q 52 100 52 95 L 52 40 Z" fill="#9CA3AF"/>
                        <!-- Nh√≥m c√°nh qu·∫°t (ƒë·ªÉ xoay) --><g class="turbine-blades">
                            <!-- C√°nh 1 -->
                            <path d="M 50 35 L 65 20 L 70 25 L 55 40 Z" fill="#F3F4F6" stroke="#9CA3AF" stroke-width="1.5" transform="rotate(0 50 35)"/>
                            <!-- C√°nh 2 -->
                            <path d="M 50 35 L 65 20 L 70 25 L 55 40 Z" fill="#F3F4F6" stroke="#9CA3AF" stroke-width="1.5" transform="rotate(120 50 35)"/>
                            <!-- C√°nh 3 -->
                            <path d="M 50 35 L 65 20 L 70 25 L 55 40 Z" fill="#F3F4F6" stroke="#9CA3AF" stroke-width="1.5" transform="rotate(240 50 35)"/>
                        </g>
                        <!-- T√¢m --><circle cx="50" cy="35" r="7" fill="#6B7280" stroke="#4B5563" stroke-width="2"/>
                    </svg>
                </div>
            </div>

            <!-- H√†ng 3 --><div class="tool-cell">
                <!-- C√îNG C·ª§ 5: C√îNG T·∫ÆC (C·∫¨P NH·∫¨T) -->
                <div class="tool-item" data-tool="switch" title="C√¥ng t·∫Øc">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <rect x="20" y="20" width="60" height="60" rx="10" fill="#E5E7EB" stroke="#4B5563" stroke-width="3"/>
                        
                        <!-- Ch·ªØ OFF (·ªü tr√™n) -->
                        <text x="50" y="38" class="switch-text switch-text-off">OFF</text>
                        
                        <!-- C·∫ßn g·∫°t (V·ªã tr√≠ Y ƒë∆∞·ª£c ƒëi·ªÅu khi·ªÉn b·∫±ng CSS) -->
                        <rect class="switch-lever" x="40" y="45" width="20" height="30" rx="5"/>

                        <!-- Ch·ªØ ON (·ªü d∆∞·ªõi) -->
                        <text x="50" y="70" class="switch-text switch-text-on">ON</text>
                    </svg>
                </div>
            </div>
            <div class="tool-cell">
                <!-- C√îNG C·ª§ 6: B√ìNG ƒê√àN (C·∫¨P NH·∫¨T) -->
                <div class="tool-item" data-tool="light-bulb" title="B√≥ng ƒë√®n">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                         <!-- ƒêu√¥i ƒë√®n -->
                        <rect x="35" y="60" width="30" height="20" fill="#9CA3AF" stroke="#4B5563" stroke-width="2"/>
                        <rect x="38" y="80" width="24" height="5" fill="#6B7280"/>
                         <!-- Ph·∫ßn th·ªßy tinh (T·∫ÆT, m√†u x√°m) -->
                        <circle class="bulb-glass" cx="50" cy="40" r="30" stroke="#4B5563" stroke-width="2"/>
                    </svg>
                </div>
            </div>
            
            <!-- H√†ng 4 --><div class="tool-cell">
                <!-- C√¥ng c·ª• 7: T·ªß ƒëi·ªán (C·∫¨P NH·∫¨T: Th√™m b·∫£ng t√™n) --><div class="tool-item" data-tool="power-box" title="T·ªß ƒëi·ªán">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <rect x="20" y="15" width="60" height="70" rx="8" fill="#6B7280" stroke="#374151" stroke-width="3"/>
                        <rect x="28" y="25" width="44" height="50" rx="4" fill="#D1D5DB" stroke="#4B5563" stroke-width="2"/>
                        <circle cx="38" cy="50" r="5" fill="#EF4444"/>
                        <circle cx="62" cy="50" r="5" fill="#22C55E"/>
                        <!-- B·∫£ng t√™n -->
                        <text x="50" y="80" class="power-box-label">T·ªß ƒëi·ªán</text>
                    </svg>
                </div>
            </div>
            <div class="tool-cell" id="wire-tool-cell">
                <!-- C√¥ng c·ª• 8: D√¢y d·∫´n ƒëi·ªán (SVG) - N√∫t k√≠ch ho·∫°t ch·∫ø ƒë·ªô --><div class="tool-item" data-tool="wire" title="D√¢y d·∫´n ƒëi·ªán">
                    <svg class="svg-icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 20 20 Q 50 80 80 80" stroke="#F59E0B" stroke-width="8" fill="none" stroke-linecap="round"/>
                        <circle cx="20" cy="20" r="10" fill="#3B82F6"/>
                        <circle cx="80" cy="80" r="10" fill="#3B82F6"/>
                    </svg>
                </div>
            </div>
            
            <!-- H√†ng 5 --><div class="tool-cell">
                <div class="tool-item" data-tool="cloud" title="ƒê√°m m√¢y">‚òÅÔ∏è</div>
            </div>
            <div class="tool-cell">
                <div class="tool-item" data-tool="wind" title="Lu·ªìng gi√≥ th·ªïi">üí®</div>
            </div>

            <!-- H√†ng 6 (C·∫≠p nh·∫≠t) --><div class="tool-cell" style="padding: 4px;"> <!-- Th√™m padding ƒë·ªÉ n√∫t ƒë·∫πp h∆°n -->
                <div id="undo-btn" class="tool-item" title="Ho√†n t√°c" style="cursor: pointer; background-color: #3B82F6; color: white; font-weight: bold; font-size: 1.2rem; border-radius: 8px; border: 2px solid white; width: 100%; height: 100%;">
                    Undo
                </div>
            </div>
            <div class="tool-cell" style="padding: 4px;"> <!-- Th√™m padding ƒë·ªÉ n√∫t ƒë·∫πp h∆°n -->
                <div id="reset-btn" class="tool-item" title="Thi·∫øt l·∫≠p l·∫°i" style="cursor: pointer; background-color: #EF4444; color: white; font-weight: bold; font-size: 1.2rem; border-radius: 8px; border: 2px solid white; width: 100%; height: 100%;">
                     Reset
                </div>
            </div>
        </div>
    </div>

    <!-- TH√äM M·ªöI: Audio element for TTS -->
    <audio id="ai-audio" style="display: none;"></audio>


    <script>
        const dropZone = document.getElementById('model-a');
        const toolBox = document.getElementById('tools-b');
        const wireToolCell = document.getElementById('wire-tool-cell');
        const wireLayer = document.getElementById('wire-svg-layer');
        // TH√äM M·ªöI: L·∫•y element AI Bot
        const aiExplanationElement = document.getElementById('ai-explanation');
        // TH√äM M·ªöI: L·∫•y element Input, Button v√† Loader c·ªßa AI
        const aiQuestionInput = document.getElementById('ai-question');
        const aiSendButton = document.getElementById('ai-send-btn');
        const aiLoader = document.getElementById('ai-loader');
        // TH√äM M·ªöI: L·∫•y Audio element
        const aiAudioElement = document.getElementById('ai-audio');
        // TH√äM M·ªöI: N√∫t Reset/Undo
        const resetButton = document.getElementById('reset-btn');
        const undoButton = document.getElementById('undo-btn');


        let draggedItem = null;      
        let draggedItemCopy = null; 
        let offsetX, offsetY;
        
        // S·ª¨A L·ªñI CLICK C√îNG T·∫ÆC: Bi·∫øn theo d√µi tr·∫°ng th√°i k√©o
        let isDragging = false; // Theo d√µi n·∫øu ƒëang k√©o (k·ªÉ c·∫£ clone ho·∫∑c move)
        let isPotentialDrag = false; // Theo d√µi n·∫øu nh·∫•n chu·ªôt (c√≥ th·ªÉ l√† click ho·∫∑c drag)
        
        let isWiringMode = false; 

        // WIRING VARIABLES
        let wiringStartItem = null;
        let tempWire = null;
        // Danh s√°ch c√°c c√¥ng c·ª• c√≥ th·ªÉ tham gia n·ªëi d√¢y
        const wiringParticipants = ['power-box', 'solar-panel', 'wind-turbine', 'light-bulb', 'switch'];
        // DANH S√ÅCH C√îNG C·ª§ ƒê·ªòC QUY·ªÄN (tr·ª´ M√¢y v√† D√¢y)
        const exclusiveTools = ['sun', 'house', 'solar-panel', 'wind-turbine', 'switch', 'light-bulb', 'power-box', 'wind'];
        
        // BI·∫æN TR·∫†NG TH√ÅI TO√ÄN C·ª§C (QUAN TR·ªåNG)
        let isSunnyGlobal = false; // Tr·∫°ng th√°i C√ì N·∫ÆNG (M·∫∑t tr·ªùi c√≥ V√Ä kh√¥ng b·ªã che)
        
        // TH√äM M·ªöI: Bi·∫øn cho Undo/Redo
        let historyStack = [];
        const MAX_HISTORY = 30; // Gi·ªõi h·∫°n 30 b∆∞·ªõc



        
        // === H√ÄM H·ªñ TR·ª¢ ===
        
        // TH√äM M·ªöI: H√†m c·∫≠p nh·∫≠t gi·∫£i th√≠ch AI Bot
        function updateAIExplanation(message) {
             // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu kh√¥ng ƒëang t·∫£i
             if (aiLoader.classList.contains('hidden')) {
                aiExplanationElement.textContent = message;
             }
        }

        function generateUUID() {
            return 'item-' + Date.now() + '-' + Math.random().toString(16).slice(2);
        }

        // S·ª¨A L·ªñI TOUCH: Th√™m h√†m chu·∫©n h√≥a s·ª± ki·ªán
        function getEvent(evt) {
            return evt.touches ? evt.touches[0] : evt;
        }

        // L·∫•y t·ªça ƒë·ªô chu·ªôt t∆∞∆°ng ƒë·ªëi v·ªõi dropZone
        function getMousePos(evt) {
            // S·ª¨A: Chu·∫©n h√≥a s·ª± ki·ªán chu·ªôt v√† ch·∫°m
            const event = getEvent(evt); 
            const rect = dropZone.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }
        
        // L·∫•y t·ªça ƒë·ªô t√¢m c·ªßa m·ªôt c√¥ng c·ª• (t∆∞∆°ng ƒë·ªëi v·ªõi dropZone)
        function getCenter(element) {
            const rect = element.getBoundingClientRect();
            const dropZoneRect = dropZone.getBoundingClientRect();
            // Tr·∫£ v·ªÅ trung t√¢m h√¨nh h·ªçc
            return {
                x: (rect.left + rect.right) /2 - dropZoneRect.left,
                y: (rect.top + rect.bottom) / 2 - dropZoneRect.top
            };
        }
        
        // L·∫•y t·ªça ƒë·ªô ƒëi·ªÉm n·ªëi ·ªü ƒë√°y (t∆∞∆°ng ƒë·ªëi v·ªõi dropZone)
        function getBottomCenter(element) {
            const rect = element.getBoundingClientRect();
            const dropZoneRect = dropZone.getBoundingClientRect();
            // Tr·∫£ v·ªÅ trung t√¢m x, c·∫°nh ƒë√°y y
            return {
                x: (rect.left + rect.right) / 2 - dropZoneRect.left,
                y: rect.bottom - dropZoneRect.top 
            };
        }

        // L·∫•y t·ªça ƒë·ªô ƒëi·ªÉm n·ªëi ·ªü ƒë·ªânh (t∆∞∆°ng ƒë·ªëi v·ªõi dropZone)
        function getTopCenter(element) {
            const rect = element.getBoundingClientRect();
            const dropZoneRect = dropZone.getBoundingClientRect();
            // Tr·∫£ v·ªÅ trung t√¢m x, c·∫°nh ƒë·ªânh y
            return {
                x: (rect.left + rect.right) / 2 - dropZoneRect.left,
                y: rect.top - dropZoneRect.top 
            };
        }
        
        // L·∫•y t·ªça ƒë·ªô ƒëi·ªÉm n·ªëi ·ªü c·∫°nh b√™n g·∫ßn nh·∫•t (t∆∞∆°ng ƒë·ªëi v·ªõi dropZone)
        function getClosestSideCenter(element, targetElement) {
            const rect = element.getBoundingClientRect();
            const dropZoneRect = dropZone.getBoundingClientRect();
            const targetCenter = getCenter(targetElement);
            const elementCenter = getCenter(element);

            let xPos;
            
            // N·∫øu element (Item) n·∫±m b√™n tr√°i target (PBox), d√πng c·∫°nh ph·∫£i c·ªßa Item.
            if (elementCenter.x < targetCenter.x) {
                xPos = rect.right - dropZoneRect.left;
            } else {
                // N·∫øu element (Item) n·∫±m b√™n ph·∫£i target (PBox), d√πng c·∫°nh tr√°i c·ªßa Item.
                xPos = rect.left - dropZoneRect.left;
            }
            
            // Tr·∫£ v·ªÅ trung t√¢m y, c·∫°nh x g·∫ßn nh·∫•t
            return {
                x: xPos,
                y: elementCenter.y
            };
        }
        
        // H√ÄM H·ªñ TR·ª¢ T√çNH TO√ÅN OVERLAP (AABB)
        function getOverlap(rect1, rect2) {
            const overlapLeft = Math.max(rect1.left, rect2.left);
            const overlapRight = Math.min(rect1.right, rect2.right);
            const overlapTop = Math.max(rect1.top, rect2.top);
            const overlapBottom = Math.min(rect1.bottom, rect2.bottom);

            if (overlapRight > overlapLeft && overlapBottom > overlapTop) {
                return (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
            }
            return 0; // No overlap
        }

        // === TH√äM M·ªöI: H√ÄM H·ªñ TR·ª¢ TTS ===
        /**
         * Chuy·ªÉn ƒë·ªïi chu·ªói Base64 th√†nh ArrayBuffer.
         * @param {string} base64 Chu·ªói Base64.
         * @returns {ArrayBuffer} D·ªØ li·ªáu ArrayBuffer.
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu PCM (Int16Array) th√†nh WAV blob.
         * @param {Int16Array} pcmData D·ªØ li·ªáu PCM.
         * @param {number} sampleRate T·∫ßn s·ªë l·∫•y m·∫´u (v√≠ d·ª•: 24000).
         * @returns {Blob | null} D·ªØ li·ªáu WAV d∆∞·ªõi d·∫°ng Blob ho·∫∑c null n·∫øu l·ªói.
         */
        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * bytesPerSample;
            // RIFF chunk descriptor (12 bytes) + fmt sub-chunk (24 bytes) + data sub-chunk header (8 bytes) = 44 bytes header
            const headerSize = 44;
             // S·ª¨A L·ªñI: T√≠nh to√°n fileSize ch√≠nh x√°c
            const fileSize = headerSize + dataSize; // Total file size including header and data

            // Check if pcmData length makes sense (avoid huge allocations)
            if (pcmData.length > 5 * 1024 * 1024) { // Limit to ~10MB PCM data ~ several minutes
                 console.error("PCM data too large, aborting WAV creation.");
                 return null;
            }
             // Ensure sufficient buffer size, handle potential errors
            let buffer;
            try {
                 buffer = new ArrayBuffer(fileSize);
            } catch (e) {
                console.error("Failed to allocate ArrayBuffer:", e);
                return null;
            }

            // Check if buffer allocation failed (e.g., due to size) - This check might be redundant after try-catch but good for clarity
            if (!buffer || buffer.byteLength !== fileSize) {
                 console.error("Failed to allocate ArrayBuffer of size:", fileSize);
                 return null;
            }


            const view = new DataView(buffer);

            // RIFF header (Bytes 0-11)
            writeString(view, 0, 'RIFF');
            view.setUint32(4, fileSize - 8, true); // ChunkSize = Total file size - 8 bytes for "RIFF" and ChunkSize field
            writeString(view, 8, 'WAVE');

            // fmt chunk (Bytes 12-35)
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true); // AudioFormat (1 = PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true); // byteRate = sampleRate * numChannels * bytesPerSample
            view.setUint16(32, blockAlign, true); // blockAlign = numChannels * bytesPerSample
            view.setUint16(34, bytesPerSample * 8, true); // bitsPerSample = 16

            // data chunk header (Bytes 36-43)
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true); // Subchunk2Size = dataSize

            // PCM data (Bytes 44 onwards)
            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                 // Check bounds defensively, although theoretically correct now
                 if (offset + bytesPerSample > fileSize) {
                     console.error(`Attempting to write beyond buffer bounds at sample ${i}. Offset: ${offset}, FileSize: ${fileSize}`);
                     break; // Stop writing further data
                 }
                view.setInt16(offset, pcmData[i], true);
                offset += bytesPerSample;
            }
             // Optional: Check if the final offset matches the expected end of data
            if (offset !== headerSize + dataSize) {
                 console.warn(`Final offset ${offset} does not match expected end of data ${headerSize + dataSize}`);
                 // Consider returning null or handling the partial data if the loop broke early
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }


        // === H√ÄM QU·∫¢N L√ù D√ÇY D·∫™N ===

        /**
         * X√≥a t·∫•t c·∫£ c√°c d√¢y d·∫´n ƒë∆∞·ª£c n·ªëi v·ªõi m·ªôt c√¥ng c·ª• (d·ª±a tr√™n itemId)
         * @param {string} itemId ID c·ªßa c√¥ng c·ª• b·ªã x√≥a.
         */
        function removeWires(itemId) {
            const wires = Array.from(wireLayer.querySelectorAll('.permanent-wire'));
            wires.forEach(wire => {
                if (wire.dataset.startId === itemId || wire.dataset.endId === itemId) {
                    wire.remove();
                }
            });
        }
        
        /**
         * KI·ªÇM TRA XEM C√îNG T·∫ÆC/ƒê√àN C√ì ƒê∆Ø·ª¢C N·ªêI D√ÇY KH√îNG
         */
        function isItemWired(item) {
            if (!item) return false;
            const itemId = item.dataset.itemId;
            const wire = wireLayer.querySelector(`.permanent-wire[data-start-id="${itemId}"], .permanent-wire[data-end-id="${itemId}"]`);
            return !!wire; // Tr·∫£ v·ªÅ true n·∫øu t√¨m th·∫•y d√¢y, ng∆∞·ª£c l·∫°i false
        }

        /**
         * T√≠nh to√°n ƒë∆∞·ªùng ƒëi (path D) cho d√¢y d·∫´n d·ª±a tr√™n lo·∫°i c√¥ng c·ª•
         * @param {Element} startEl 
         * @param {Element} endEl 
         * @returns {string} Chu·ªói d c·ªßa SVG path
         */
        function calculateWirePath(startEl, endEl) {
            // Th√™m ki·ªÉm tra null ph√≤ng tr∆∞·ªùng h·ª£p 1 trong 2 b·ªã thi·∫øu
            if (!startEl || !endEl) return ""; 

            const startType = startEl.dataset.tool;
            const endType = endEl.dataset.tool;
            let pathD;

            // KI·ªÇM TRA K·∫æT N·ªêI ƒê·∫∂C BI·ªÜT
            const isTurbineConnection = (startType === 'power-box' && endType === 'wind-turbine') || 
                                       (startType === 'wind-turbine' && endType === 'power-box');
            
            const isSolarConnection = (startType === 'power-box' && endType === 'solar-panel') || 
                                      (startType === 'solar-panel' && endType === 'power-box');
                                      
            const isSwitchConnection = (startType === 'power-box' && endType === 'switch') ||
                                       (startType === 'switch' && endType === 'power-box');
                                       
            const isLightBulbConnection = (startType === 'power-box' && endType === 'light-bulb') ||
                                          (startType === 'light-bulb' && endType === 'power-box');

            if (isTurbineConnection) {
                // LOGIC N·ªêI D√ÇY TUA-BIN G√ìC VU√îNG (T·ªß ƒëi·ªán <-> Tua-bin)
                const PBox = startType === 'power-box' ? startEl : endEl;
                const Turbine = startType === 'wind-turbine' ? startEl : endEl;
                const S = getBottomCenter(PBox); 
                const E = getBottomCenter(Turbine);
                const commonY = Math.max(S.y, E.y) + 15; // ƒêi·ªÉm chung d∆∞·ªõi "m·∫∑t ƒë·∫•t"
                pathD = `M ${S.x} ${S.y} L ${S.x} ${commonY} L ${E.x} ${commonY} L ${E.x} ${E.y}`;
                
            } else if (isSolarConnection) {
                 // LOGIC N·ªêY D√ÇY PIN M·∫∂T TR·ªúI G√ìC VU√îNG (Horizontal then Vertical)
                const PBox = startType === 'power-box' ? startEl : endEl;
                const Solar = startType === 'solar-panel' ? startEl : endEl;
                const P1 = getClosestSideCenter(Solar, PBox); // C·∫°nh b√™n Pin m·∫∑t tr·ªùi
                const P4 = getTopCenter(PBox); // ƒê·ªânh T·ªß ƒëi·ªán
                const P2 = { x: P4.x, y: P1.y }; // ƒêi·ªÉm r·∫Ω g√≥c 90 ƒë·ªô
                pathD = `M ${P1.x} ${P1.y} L ${P2.x} ${P2.y} L ${P4.x} ${P4.y}`;

            } else if (isSwitchConnection) {
                // C·∫¨P NH·∫¨T: LOGIC N·ªêI D√ÇY C√îNG T·∫ÆC (Gi·ªëng Tua-bin)
                const PBox = startType === 'power-box' ? startEl : endEl;
                const Switch = startType === 'switch' ? startEl : endEl;
                const S = getBottomCenter(PBox); 
                const E = getBottomCenter(Switch);
                const commonY = Math.max(S.y, E.y) + 15; // ƒêi·ªÉm chung d∆∞·ªõi "m·∫∑t ƒë·∫•t"
                pathD = `M ${S.x} ${S.y} L ${S.x} ${commonY} L ${E.x} ${commonY} L ${E.x} ${E.y}`;
                
            } else if (isLightBulbConnection) {
                // LOGIC N·ªêI D√ÇY B√ìNG ƒê√àN G√ìC VU√îNG (Horizontal then Vertical)
                const PBox = startType === 'power-box' ? startEl : endEl;
                const LightBulb = startType === 'light-bulb' ? startEl : endEl;
                const P1 = getBottomCenter(LightBulb); // ƒê√°y B√≥ng ƒë√®n
                const P4 = getTopCenter(PBox); // ƒê·ªânh T·ªß ƒëi·ªán
                const P2 = { x: P4.x, y: P1.y }; // ƒêi·ªÉm r·∫Ω g√≥c 90 ƒë·ªô
                pathD = `M ${P1.x} ${P1.y} L ${P2.x} ${P2.y} L ${P4.x} ${P4.y}`;

            } else {
                // LOGIC M·∫∂C ƒê·ªäNH cho c√°c k·∫øt n·ªëi kh√°c (Bezier curve)
                const startPos = getCenter(startEl);
                const endPos = getCenter(endEl);
                pathD = `M ${startPos.x} ${startPos.y} Q ${startPos.x} ${endPos.y} ${endPos.x} ${endPos.y}`;
            }
            
            return pathD;
        }

        // V·∫º D√ÇY Vƒ®NH VI·ªÑN
        function createPermanentWire(startEl, endEl) {
            const startId = startEl.dataset.itemId;
            const endId = endEl.dataset.itemId;
            
            const pathD = calculateWirePath(startEl, endEl);
            
            const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            wire.setAttribute('class', 'permanent-wire');
            wire.dataset.startId = startId;
            wire.dataset.endId = endId;
            wire.setAttribute('d', pathD);
            
            wireLayer.prepend(wire); 
            // TH√äM M·ªöI: AI Bot gi·∫£i th√≠ch
             const explanation = `ƒê√£ n·ªëi d√¢y gi·ªØa ${startEl.title} v√† ${endEl.title}.`;
             updateAIExplanation(explanation);
             callTTSAPI(explanation); // G·ªçi TTS
        }

        /**
         * C·∫≠p nh·∫≠t t·∫•t c·∫£ c√°c d√¢y d·∫´n ƒë∆∞·ª£c n·ªëi v·ªõi m·ªôt c√¥ng c·ª• ƒëang di chuy·ªÉn
         * @param {string} itemId ID c·ªßa c√¥ng c·ª• ƒëang di chuy·ªÉn
         */
        function updateConnectedWires(itemId) {
            const wires = Array.from(wireLayer.querySelectorAll('.permanent-wire'));
            const movingItem = document.querySelector(`[data-item-id="${itemId}"]`);
            if (!movingItem) return;

            wires.forEach(wire => {
                let startEl, endEl;
                
                if (wire.dataset.startId === itemId) {
                    startEl = movingItem;
                    endEl = document.querySelector(`[data-item-id="${wire.dataset.endId}"]`);
                } else if (wire.dataset.endId === itemId) {
                    startEl = document.querySelector(`[data-item-id="${wire.dataset.startId}"]`);
                    endEl = movingItem;
                } else {
                    return; // B·ªè qua n·∫øu d√¢y kh√¥ng li√™n quan
                }

                if (startEl && endEl) {
                    const newPathD = calculateWirePath(startEl, endEl);
                    wire.setAttribute('d', newPathD);
                }
            });
        }
        
        // === H√ÄM QU·∫¢N L√ù TR·∫†NG TH√ÅI M√î PH·ªéNG ===
        
        // TH√äM M·ªöI: Bi·∫øn l∆∞u tr·ªØ tin nh·∫Øn cu·ªëi c√πng ƒë·ªÉ tr√°nh l·∫∑p l·∫°i
        let lastAIMessage = "";
        
        /**
         * H√ÄM CH·ª¶: C·∫≠p nh·∫≠t to√†n b·ªô tr·∫°ng th√°i m√¥ ph·ªèng
         * ƒê√¢y l√† h√†m ƒëi·ªÅu khi·ªÉn ch√≠nh, g·ªçi c√°c h√†m con theo th·ª© t·ª±.
         */
        function updateAllSimulationStates(actionContext = null) { // Th√™m context ƒë·ªÉ bi·∫øt h√†nh ƒë·ªông
            // 1. C·∫≠p nh·∫≠t tr·∫°ng th√°i c√≥ n·∫Øng (M·∫∑t tr·ªùi c√≥ & kh√¥ng b·ªã che) v√† m√†u n·ªÅn
            const previouslySunny = isSunnyGlobal; // L∆∞u tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥
            isSunnyGlobal = checkSunAndCloudsAndUpdateBackground();
            
            // 2. C·∫≠p nh·∫≠t Pin m·∫∑t tr·ªùi (d·ª±a v√†o isSunnyGlobal)
            updateSolarPanelState(isSunnyGlobal);
            
            // 3. C·∫≠p nh·∫≠t Gi√≥ (Tua-bin quay)
            const wasSpinning = !!document.querySelector('#model-a [data-tool="wind-turbine"].spinning'); // L∆∞u tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥
            updateWindAnimation();
            const isSpinning = !!document.querySelector('#model-a [data-tool="wind-turbine"].spinning');
            
            // 4. C·∫≠p nh·∫≠t ƒê√®n (d·ª±a v√†o Pin, Gi√≥, C√¥ng t·∫Øc)
            const wasLightOn = !!document.querySelector('#model-a [data-tool="light-bulb"].bulb-on'); // L∆∞u tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥
            updateLightBulbState();
             const isLightOnNow = !!document.querySelector('#model-a [data-tool="light-bulb"].bulb-on');
            
            // 5. C·∫≠p nh·∫≠t D√¢y d·∫´n (d·ª±a v√†o Pin, Gi√≥, V√Ä TR·∫†NG TH√ÅI ƒê√àN)
            updatePowerGrid(); 
            
            // 6. C·∫≠p nh·∫≠t tr·∫°ng th√°i H·ªôp c√¥ng c·ª•
            updateToolboxAvailability();
            
            // 7. C·∫¨P NH·∫¨T AI Bot (Ch·ªâ khi kh√¥ng c√≥ h√†nh ƒë·ªông n√†o kh√°c ƒëang ƒë∆∞·ª£c gi·∫£i th√≠ch)
            if (actionContext === null) {
                 if (!isDragging && !isWiringMode && wiringStartItem === null && aiLoader.classList.contains('hidden')) {
                    let explanation = ""; // Bi·∫øn l∆∞u gi·∫£i th√≠ch
                    if (previouslySunny !== isSunnyGlobal) {
                         explanation = isSunnyGlobal ? "M·∫∑t tr·ªùi ƒëang chi·∫øu s√°ng! T·∫•m pin nƒÉng l∆∞·ª£ng ƒëang t·∫°o ra ƒëi·ªán." : "Tr·ªùi kh√¥ng c√≤n n·∫Øng (do m√¢y che ho·∫∑c kh√¥ng c√≥ m·∫∑t tr·ªùi). T·∫•m pin nƒÉng l∆∞·ª£ng ng·ª´ng ho·∫°t ƒë·ªông.";
                    } else if (wasSpinning !== isSpinning) {
                         explanation = isSpinning ? "C√≥ gi√≥ th·ªïi! Tua-bin gi√≥ ƒëang quay v√† t·∫°o ra ƒëi·ªán." : "Gi√≥ ƒë√£ ng·ª´ng th·ªïi. Tua-bin gi√≥ d·ª´ng l·∫°i v√† kh√¥ng t·∫°o ra ƒëi·ªán n·ªØa.";
                    } else if (wasLightOn !== isLightOnNow) {
                        if (isLightOnNow) {
                            // Logic gi·∫£i th√≠ch NGUY√äN L√ù ƒë√®n s√°ng
                            const isWiredTurbineSpinning = !!document.querySelector('#model-a [data-tool="wind-turbine"].spinning') && isItemWired(document.querySelector('#model-a [data-tool="wind-turbine"]'));
                            const isWiredSolarActive = isSunnyGlobal && !!document.querySelector('#model-a [data-tool="solar-panel"]') && isItemWired(document.querySelector('#model-a [data-tool="solar-panel"]'));

                            if (isWiredTurbineSpinning && isWiredSolarActive) {
                                explanation = "ƒê√®n ƒë√£ s√°ng! H·ªá th·ªëng ƒëang d√πng c·∫£ nƒÉng l∆∞·ª£ng m·∫∑t tr·ªùi v√† nƒÉng l∆∞·ª£ng gi√≥.";
                            } else if (isWiredSolarActive) {
                                explanation = "ƒê√®n ƒë√£ s√°ng! Pin m·∫∑t tr·ªùi ƒëang chuy·ªÉn ƒë·ªïi √°nh n·∫Øng th√†nh ƒëi·ªán ƒë·ªÉ th·∫Øp s√°ng ƒë√®n.";
                            } else if (isWiredTurbineSpinning) {
                                explanation = "ƒê√®n ƒë√£ s√°ng! Tua-bin ƒëang d√πng s·ª©c gi√≥ ƒë·ªÉ t·∫°o ra ƒëi·ªán th·∫Øp s√°ng ƒë√®n.";
                            } else {
                                explanation = "ƒê√®n ƒë√£ s√°ng!"; // Fallback
                            }
                        } else {
                             explanation = "ƒê√®n ƒë√£ t·∫Øt. Ki·ªÉm tra l·∫°i ngu·ªìn ƒëi·ªán, d√¢y d·∫´n v√† c√¥ng t·∫Øc nh√©.";
                        }
                    }
                    
                    // Ch·ªâ c·∫≠p nh·∫≠t v√† ƒë·ªçc n·∫øu c√≥ gi·∫£i th√≠ch m·ªõi
                    if (explanation && explanation !== lastAIMessage) {
                        updateAIExplanation(explanation);
                        callTTSAPI(explanation); 
                        lastAIMessage = explanation;
                    }
                }
            }
        }
        
        /**
         * 1. Ki·ªÉm tra M·∫∑t tr·ªùi, M√¢y che, c·∫≠p nh·∫≠t n·ªÅn tr·ªùi v√† tr·∫°ng th√°i isSunnyGlobal
         * @returns {boolean} Tr·∫£ v·ªÅ true n·∫øu C√ì N·∫ÆNG (M·∫∑t tr·ªùi c√≥ V√Ä kh√¥ng b·ªã che)
         */
        function checkSunAndCloudsAndUpdateBackground() {
            const sun = document.querySelector('#model-a [data-tool="sun"]');
            const clouds = document.querySelectorAll('#model-a [data-tool="cloud"]');
            
            let isSunny = false; // M·∫∑c ƒë·ªãnh l√† kh√¥ng c√≥ n·∫Øng
            
            if (sun) {
                // C√ì c√¥ng c·ª• m·∫∑t tr·ªùi
                
                // Ki·ªÉm tra m√¢y che
                const sunRect = sun.getBoundingClientRect();
                const sunArea = (sunRect.right - sunRect.left) * (sunRect.bottom - sunRect.top);
                let totalOverlap = 0;

                clouds.forEach(cloud => {
                    const cloudRect = cloud.getBoundingClientRect();
                    totalOverlap += getOverlap(sunRect, cloudRect);
                });

                // N·∫øu kh√¥ng b·ªã che qu√° 50% -> C√ì N·∫ÆNG v√† n·ªÅn xanh l√° s√°ng
                if (totalOverlap <= (sunArea * 0.5)) {
                    isSunny = true;
                    dropZone.classList.add('sun-present-bg');
                    dropZone.classList.remove('sky-partly-cloudy');
                } else {
                    // B·ªã che -> KH√îNG c√≥ n·∫Øng v√† n·ªÅn xanh l√° pha x√°m
                    isSunny = false;
                    dropZone.classList.remove('sun-present-bg');
                    dropZone.classList.add('sky-partly-cloudy');
                    // updateAIExplanation("M√¢y ƒëang che m·∫∑t tr·ªùi, pin m·∫∑t tr·ªùi kh√¥ng ho·∫°t ƒë·ªông."); // Di chuy·ªÉn v√†o h√†m ch√≠nh
                }
                
            } else {
                // KH√îNG c√≥ c√¥ng c·ª• m·∫∑t tr·ªùi -> N·ªÅn x√°m ƒë·∫≠m (m·∫∑c ƒë·ªãnh) v√† kh√¥ng c√≥ n·∫Øng
                dropZone.classList.remove('sun-present-bg');
                dropZone.classList.remove('sky-partly-cloudy');
                isSunny = false; // Kh√¥ng c√≥ n·∫Øng
            }
            
            return isSunny; // Tr·∫£ v·ªÅ tr·∫°ng th√°i c√≥ n·∫Øng
        }
        
        /**
         * 2. C·∫≠p nh·∫≠t tr·∫°ng th√°i Pin m·∫∑t tr·ªùi (nh·∫•p nh√°y)
         * @param {boolean} isSunny Tr·∫°ng th√°i c√≥ n·∫Øng (ƒë√£ t√≠nh to√°n)
         */
        function updateSolarPanelState(isSunny) {
            const solarPanels = document.querySelectorAll('#model-a [data-tool="solar-panel"]');

            solarPanels.forEach(panel => {
                // Pin ch·ªâ active khi C√ì N·∫ÆNG
                if (isSunny) {
                    panel.classList.add('solar-active');
                } else {
                    panel.classList.remove('solar-active');
                }
            });
            
            // updatePowerGrid(); // S·∫Ω ƒë∆∞·ª£c g·ªçi trong h√†m updateAllSimulationStates
        }

        /**
         * 3. C·∫¨P NH·∫¨T ANIMATION GI√ì
         */
        function updateWindAnimation() {
            const windIsPresent = !!document.querySelector('#model-a [data-tool="wind"]');
            const turbines = document.querySelectorAll('#model-a [data-tool="wind-turbine"]');

            turbines.forEach(turbine => {
                if (windIsPresent) {
                    turbine.classList.add('spinning');
                } else {
                    turbine.classList.remove('spinning');
                }
            });
            
            // updatePowerGrid(); // S·∫Ω ƒë∆∞·ª£c g·ªçi trong h√†m updateAllSimulationStates
        }
        
        /**
         * 4. C·∫≠p nh·∫≠t tr·∫°ng th√°i B√≥ng ƒë√®n (B·∫≠t/T·∫Øt)
         */
        function updateLightBulbState() {
            const lightBulbs = document.querySelectorAll('#model-a [data-tool="light-bulb"]');
            if (lightBulbs.length === 0) return; // Kh√¥ng c√≥ ƒë√®n, b·ªè qua

            // C·∫¨P NH·∫¨T LOGIC: Ki·ªÉm tra ngu·ªìn C√ì D√ÇY
            const turbineEl = document.querySelector('#model-a [data-tool="wind-turbine"]');
            const solarPanelEl = document.querySelector('#model-a [data-tool="solar-panel"]');
            
            const isWiredTurbineSpinning = turbineEl && turbineEl.classList.contains('spinning') && isItemWired(turbineEl);
            const isWiredSolarActive = isSunnyGlobal && solarPanelEl && isItemWired(solarPanelEl);
            
            const isPowerAvailable = isWiredTurbineSpinning || isWiredSolarActive;

            // Ki·ªÉm tra c√¥ng t·∫Øc
            const mainSwitch = document.querySelector('#model-a [data-tool="switch"]');
            
            let isLightOn = false;
            
            // Logic ƒë√®n s√°ng
            if (mainSwitch) {
                // C√ì C√îNG T·∫ÆC: ƒê√®n s√°ng = Ngu·ªìn C√ì D√ÇY V√Ä C√¥ng t·∫Øc B·∫¨T V√Ä C√¥ng t·∫Øc C√ì D√ÇY
                if (isPowerAvailable && 
                    mainSwitch.classList.contains('switch-on') &&
                    isItemWired(mainSwitch) ) { 
                    
                    isLightOn = true; 
                }
            } else {
                // KH√îNG C√ì C√îNG T·∫ÆC: ƒê√®n s√°ng = Ngu·ªìn C√ì D√ÇY
                if (isPowerAvailable) {
                    isLightOn = true;
                }
            }

            // √Åp d·ª•ng tr·∫°ng th√°i cho t·∫•t c·∫£ b√≥ng ƒë√®n (V√Ä KI·ªÇM TRA D√ÇY C·ª¶A ƒê√àN)
            lightBulbs.forEach(bulb => {
                // ƒê√®n ch·ªâ s√°ng n·∫øu (isLightOn (ƒë√£ check ngu·ªìn/c√¥ng t·∫Øc/d√¢y ngu·ªìn) V√Ä ch√≠nh n√≥ (b√≥ng ƒë√®n) C√ì D√ÇY)
                if (isLightOn && isItemWired(bulb)) {
                    bulb.classList.add('bulb-on');
                } else {
                    bulb.classList.remove('bulb-on');
                }
            });
        }
        
        /**
         * 5. C·∫≠p nh·∫≠t tr·∫°ng th√°i "ho·∫°t ƒë·ªông" (n√©t ƒë·ª©t) c·ªßa d√¢y d·∫´n
         */
        function updatePowerGrid() {
            const powerBox = document.querySelector('#model-a [data-tool="power-box"]');
            const isSunny = isSunnyGlobal; 

            if (!powerBox) {
                document.querySelectorAll('.permanent-wire').forEach(w => w.classList.remove('wire-active', 'wire-reversed', 'light-wire-active'));
                return;
            }

            const powerBoxId = powerBox.dataset.itemId;
            const allWires = document.querySelectorAll('.permanent-wire');

            allWires.forEach(wire => {
                const startId = wire.dataset.startId;
                const endId = wire.dataset.endId;
                const item1 = document.querySelector(`[data-item-id="${startId}"]`);
                const item2 = document.querySelector(`[data-item-id="${endId}"]`);

                if (!item1 || !item2) {
                    wire.classList.remove('wire-active', 'wire-reversed', 'light-wire-active');
                    return;
                }

                const item1Type = item1.dataset.tool;
                const item2Type = item2.dataset.tool;

                let isActive = false;
                 // S·ª¨A L·ªñI HI·ªÜU ·ª®NG D√ÇY D·∫™N (ƒê·∫£o ng∆∞·ª£c)
                 // true = ch·∫°y START -> END (ƒë·∫£o ng∆∞·ª£c CSS), false = ch·∫°y END -> START (CSS m·∫∑c ƒë·ªãnh)
                let useReverseAnimation = false; 
                let isLightWire = false;
                let isSourceAtStart = false; // Bi·∫øn m·ªõi: X√°c ƒë·ªãnh ngu·ªìn c√≥ ph·∫£i l√† ƒëi·ªÉm b·∫Øt ƒë·∫ßu (startId) kh√¥ng

                // Case 1: Pin -> T·ªß ho·∫∑c T·ªß -> Pin
                if ((item1Type === 'solar-panel' && item2Type === 'power-box') || 
                    (item1Type === 'power-box' && item2Type === 'solar-panel')) {
                    if (isSunny) { 
                        isActive = true;
                        isSourceAtStart = (item1Type === 'solar-panel'); // Ngu·ªìn (Pin) l√† Start?
                    }
                } 
                // Case 2: Tua-bin -> T·ªß ho·∫∑c T·ªß -> Tua-bin
                else if ((item1Type === 'wind-turbine' && item2Type === 'power-box') || 
                           (item1Type === 'power-box' && item2Type === 'wind-turbine')) {
                    const turbineEl = (item1Type === 'wind-turbine') ? item1 : item2;
                    if (turbineEl.classList.contains('spinning')) {
                        isActive = true;
                         isSourceAtStart = (item1Type === 'wind-turbine'); // Ngu·ªìn (Tua-bin) l√† Start?
                    }
                }
                // Case 3: T·ªß -> ƒê√®n ho·∫∑c ƒê√®n -> T·ªß
                else if ((item1Type === 'light-bulb' && item2Type === 'power-box') || 
                           (item1Type === 'power-box' && item2Type === 'light-bulb')) {
                    const lightBulbEl = (item1Type === 'light-bulb') ? item1 : item2;
                    if (lightBulbEl.classList.contains('bulb-on')) {
                        isActive = true;
                        isLightWire = true;
                        isSourceAtStart = (item1Type === 'power-box'); // Ngu·ªìn (T·ªß) l√† Start?
                    }
                }

                // Apply classes
                if (isActive) {
                    wire.classList.add('wire-active');
                    // S·ª¨A L·ªñI HI·ªÜU ·ª®NG D√ÇY D·∫™N: ƒê·∫£o ng∆∞·ª£c logic
                    // Animation m·∫∑c ƒë·ªãnh (stroke-dashoffset 0 -> 20) ch·∫°y t·ª´ ƒêI·ªÇM CU·ªêI (END) v·ªÅ ƒêI·ªÇM ƒê·∫¶U (START) c·ªßa path.
                    // N·∫øu ngu·ªìn n·∫±m ·ªü ƒëi·ªÉm ƒê·∫¶U (isSourceAtStart = true), ch√∫ng ta c·∫ßn ƒë·∫£o ng∆∞·ª£c animation (REVERSE) ƒë·ªÉ n√≥ ch·∫°y T·ª™ ƒê·∫¶U -> CU·ªêI.
                    // N·∫øu ngu·ªìn n·∫±m ·ªü ƒëi·ªÉm CU·ªêI (isSourceAtStart = false), ch√∫ng ta KH√îNG c·∫ßn ƒë·∫£o ng∆∞·ª£c, ƒë·ªÉ n√≥ ch·∫°y T·ª™ CU·ªêI -> ƒê·∫¶U.
                    if (isSourceAtStart) {
                         wire.classList.add('wire-reversed'); // Reverse: START -> END
                    } else {
                         wire.classList.remove('wire-reversed'); // Normal: END -> START
                    }

                    if (isLightWire) {
                        wire.classList.add('light-wire-active');
                    } else {
                        wire.classList.remove('light-wire-active');
                    }
                } else {
                    wire.classList.remove('wire-active', 'wire-reversed', 'light-wire-active');
                }
            });
        }
        
        /**
         * 6. C·∫≠p nh·∫≠t tr·∫°ng th√°i H·ªôp c√¥ng c·ª• (Th√™m d·∫•u c·∫•m)
         */
         function updateToolboxAvailability() {
             const toolboxItems = toolBox.querySelectorAll('.tool-item');
             toolboxItems.forEach(item => {
                 const toolType = item.dataset.tool;
                 // B·ªè qua d√¢y d·∫´n v√† ƒë√°m m√¢y
                 if (toolType === 'wire' || toolType === 'cloud') {
                     item.classList.remove('tool-prohibited'); // ƒê·∫£m b·∫£o ch√∫ng kh√¥ng bao gi·ªù b·ªã c·∫•m
                     return;
                 }
                 
                 // Ki·ªÉm tra xem c√¥ng c·ª• c√≥ t·ªìn t·∫°i tr√™n m√†n h√¨nh A kh√¥ng
                 const itemExistsOnScreen = !!dropZone.querySelector(`.cloned-item[data-tool="${toolType}"]`);
                 
                 if (itemExistsOnScreen) {
                     item.classList.add('tool-prohibited');
                 } else {
                     item.classList.remove('tool-prohibited');
                 }
             });
         }
         
        /**
         * 7. TH√äM M·ªöI: Cung c·∫•p g·ª£i √Ω cho b∆∞·ªõc ti·∫øp theo
         */
        function provideNextStepGuidance() {
            // ƒê·ª´ng ƒë∆∞a ra g·ª£i √Ω n·∫øu ƒëang t·∫£i ho·∫∑c ƒëang n·ªëi d√¢y
            if (!aiLoader.classList.contains('hidden') || isWiringMode || wiringStartItem) return;

            const house = document.querySelector('#model-a [data-tool="house"]');
            const powerBox = document.querySelector('#model-a [data-tool="power-box"]');
            const solarPanel = document.querySelector('#model-a [data-tool="solar-panel"]');
            const turbine = document.querySelector('#model-a [data-tool="wind-turbine"]');
            const lightBulb = document.querySelector('#model-a [data-tool="light-bulb"]');
            const mainSwitch = document.querySelector('#model-a [data-tool="switch"]');

            let guidance = "";

            if (!house) {
                guidance = "H√£y b·∫Øt ƒë·∫ßu b·∫±ng c√°ch k√©o 'Ng√¥i nh√†' v√†o m√†n h√¨nh.";
            } else if (!powerBox) {
                guidance = "T·ªët l·∫Øm! B√¢y gi·ªù h√£y k√©o 'T·ªß ƒëi·ªán' ƒë·ªÉ g·∫Øn v√†o ng√¥i nh√†.";
            } else if (!solarPanel && !turbine) {
                guidance = "Ti·∫øp theo, ch√∫ng ta c·∫ßn ngu·ªìn ƒëi·ªán. H√£y th·ª≠ k√©o 'Pin m·∫∑t tr·ªùi' ho·∫∑c 'Tua-bin gi√≥'.";
            } else if (solarPanel && !isItemWired(solarPanel)) {
                guidance = "Gi·ªù h√£y d√πng 'D√¢y d·∫´n' ƒë·ªÉ n·ªëi 'Pin m·∫∑t tr·ªùi' v·ªõi 'T·ªß ƒëi·ªán'.";
            } else if (turbine && !isItemWired(turbine)) {
                guidance = "Gi·ªù h√£y d√πng 'D√¢y d·∫´n' ƒë·ªÉ n·ªëi 'Tua-bin gi√≥' v·ªõi 'T·ªß ƒëi·ªán'.";
            } else if (!lightBulb) {
                guidance = "H·ªá th·ªëng ƒë√£ c√≥ d√¢y ngu·ªìn. H√£y k√©o 'B√≥ng ƒë√®n' v√†o nh√†.";
            } else if (!isItemWired(lightBulb)) {
                guidance = "G·∫ßn xong r·ªìi! D√πng 'D√¢y d·∫´n' ƒë·ªÉ n·ªëi 'T·ªß ƒëi·ªán' v·ªõi 'B√≥ng ƒë√®n'.";
            } else if (!mainSwitch) {
                guidance = "B·∫°n c√≥ th·ªÉ th√™m 'C√¥ng t·∫Øc' ƒë·ªÉ ƒëi·ªÅu khi·ªÉn ƒë√®n. ƒê·ª´ng qu√™n n·ªëi d√¢y cho n√≥ nh√©.";
            } else if (!isItemWired(mainSwitch)) {
                 guidance = "ƒê·ª´ng qu√™n n·ªëi d√¢y cho 'C√¥ng t·∫Øc' v√†o 'T·ªß ƒëi·ªán'.";
            } else if (!isSunnyGlobal && !document.querySelector('#model-a [data-tool="wind-turbine"].spinning')) {
                 guidance = "M·∫°ch ƒë√£ ho√†n t·∫•t! Gi·ªù h√£y th√™m 'M·∫∑t tr·ªùi' (cho pin) ho·∫∑c 'Gi√≥' (cho tua-bin) ƒë·ªÉ t·∫°o ƒëi·ªán.";
            } else if (mainSwitch && !mainSwitch.classList.contains('switch-on')) {
                 guidance = "M·ªçi th·ª© ƒë√£ s·∫µn s√†ng! H√£y nh·∫•n v√†o 'C√¥ng t·∫Øc' ƒë·ªÉ b·∫≠t ƒë√®n.";
            } else if (lightBulb && lightBulb.classList.contains('bulb-on')) {
                 guidance = "L√†m t·ªët l·∫Øm! B·∫°n ƒë√£ th·∫Øp s√°ng ng√¥i nh√† b·∫±ng nƒÉng l∆∞·ª£ng xanh!";
            } else {
                guidance = "B·∫°n ƒë√£ ho√†n th√†nh m·ªôt m·∫°ch ƒëi·ªán c∆° b·∫£n! H√£y th·ª≠ th√™m m√¢y ƒë·ªÉ xem ƒëi·ªÅu g√¨ x·∫£y ra.";
            }
            
            // Ch·ªâ c·∫≠p nh·∫≠t v√† ƒë·ªçc n·∫øu l·ªùi khuy√™n kh√°c v·ªõi l·ªùi gi·∫£i th√≠ch cu·ªëi c√πng
            if (guidance && guidance !== lastAIMessage) {
                updateAIExplanation(guidance);
                callTTSAPI(guidance);
                lastAIMessage = guidance; // L∆∞u l·∫°i ƒë·ªÉ tr√°nh l·∫∑p
            }
        }


        
        // === H√ÄM T·ª∞ ƒê·ªòNG G·∫ÆN (SNAP) ===
        
        /**
         * H√ÄM CH·ª¶ M·ªöI: G·ªçi t·∫•t c·∫£ c√°c h√†m snap
         */
        function updateAllSnapPositions() {
            // D√πng setTimeout ƒë·ªÉ ƒë·∫£m b·∫£o v·ªã tr√≠ Ng√¥i nh√† ƒë∆∞·ª£c c·∫≠p nh·∫≠t
            // tr∆∞·ªõc khi g·∫Øn c√°c v·∫≠t th·ªÉ kh√°c v√†o
            setTimeout(() => {
                snapPowerBoxToHouse();
                snapSolarPanelToHouse();
                snapSwitchToHouse(); // TH√äM M·ªöI
                snapLightBulbToHouse(); // TH√äM M·ªöI
            }, 0); // 0ms delay, ch·ªâ ƒë·ªÉ ƒë·∫©y v√†o cu·ªëi h√†ng ƒë·ª£i th·ª±c thi
        }

        /**
         * H√ÄM SNAP: T·ª± ƒë·ªông g·∫Øn T·ªß ƒëi·ªán (power-box) v√†o Ng√¥i nh√† (house)
         */
        function snapPowerBoxToHouse() {
            const house = document.querySelector('#model-a [data-tool="house"]');
            const powerBox = document.querySelector('#model-a [data-tool="power-box"]');

            // Ch·ªâ th·ª±c hi·ªán khi c·∫£ hai t·ªìn t·∫°i
            if (house && powerBox) {
                // L·∫•y k√≠ch th∆∞·ªõc v√† v·ªã tr√≠ style (ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t b·∫±ng px)
                const houseTop = parseFloat(house.style.top);
                const houseLeft = parseFloat(house.style.left);
                const houseHeight = parseFloat(house.style.height);
                
                const powerBoxHeight = parseFloat(powerBox.style.height);
                const powerBoxWidth = parseFloat(powerBox.style.width);

                // T√≠nh to√°n v·ªã tr√≠ m·ªõi
                // ƒêI·ªÄU CH·ªàNH: G·∫Øn v√†o "ch√¢n m√©p t∆∞·ªùng" (d∆∞·ªõi c√πng b√™n tr√°i)
                // ƒê·∫∑t Y: G·∫ßn ƒë√°y nh√† (houseTop + houseHeight) tr·ª´ ƒëi chi·ªÅu cao T·ªß ƒëi·ªán, v√† 1 kho·∫£ng ƒë·ªám nh·ªè (10px)
                let targetY = houseTop + houseHeight - powerBoxHeight - 10; 
                let targetX = houseLeft + 5; // ƒê·∫∑t T·ªß ƒëi·ªán c√°ch m√©p tr√°i Ng√¥i nh√† 5px (b√™n trong)

                // Gi·ªõi h·∫°n trong m√†n h√¨nh
                targetX = Math.max(0, Math.min(targetX, dropZone.clientWidth - powerBoxWidth));
                targetY = Math.max(0, Math.min(targetY, dropZone.clientHeight - powerBoxHeight));
                
                // Di chuy·ªÉn T·ªß ƒëi·ªán
                powerBox.style.left = `${targetX}px`;
                powerBox.style.top = `${targetY}px`;

                // C·∫≠p nh·∫≠t d√¢y d·∫´n c·ªßa T·ªß ƒëi·ªán sau khi n√≥ di chuy·ªÉn
                if (powerBox.dataset.itemId) {
                    setTimeout(() => {
                         updateConnectedWires(powerBox.dataset.itemId);
                    }, 300); // 300ms kh·ªõp v·ªõi 'transition' trong CSS
                }
            }
        }
        
        /**
         * H√ÄM SNAP: T·ª± ƒë·ªông g·∫Øn Pin m·∫∑t tr·ªùi (solar-panel) v√†o Ng√¥i nh√† (house)
         */
        function snapSolarPanelToHouse() {
            const house = document.querySelector('#model-a [data-tool="house"]');
            const solarPanel = document.querySelector('#model-a [data-tool="solar-panel"]');

            // Ch·ªâ th·ª±c hi·ªán khi c·∫£ hai t·ªìn t·∫°i
            if (house && solarPanel) {
                const houseTop = parseFloat(house.style.top);
                const houseLeft = parseFloat(house.style.left);
                const houseWidth = parseFloat(house.style.width);
                const houseHeight = parseFloat(house.style.height); // houseHeight is 320px
                
                const solarPanelWidth = parseFloat(solarPanel.style.width); // solarPanel width is 160px
                const solarPanelHeight = parseFloat(solarPanel.style.height); // solarPanel height is 160px

                // T√≠nh to√°n v·ªã tr√≠ m·ªõi
                // ƒê·∫∑t v√†o gi·ªØa m√°i nh√†
                // M√°i nh√† (t·ª´ 10% ƒë·∫øn 40% chi·ªÅu cao c·ªßa SVG)
                let targetX = houseLeft + (houseWidth / 2) - (solarPanelWidth / 2);
                // ƒê·∫∑t n√≥ ·ªü kho·∫£ng 15% t·ª´ ƒë·ªânh c·ªßa SVG nh√†
                let targetY = houseTop + (houseHeight * 0.15) - (solarPanelHeight / 2);

                // Gi·ªõi h·∫°n trong m√†n h√¨nh
                targetX = Math.max(0, Math.min(targetX, dropZone.clientWidth - solarPanelWidth));
                targetY = Math.max(0, Math.min(targetY, dropZone.clientHeight - solarPanelHeight));
                
                // Di chuy·ªÉn Pin m·∫∑t tr·ªùi
                solarPanel.style.left = `${targetX}px`;
                solarPanel.style.top = `${targetY}px`;

                // C·∫≠p nh·∫≠t d√¢y d·∫´n c·ªßa Pin m·∫∑t tr·ªùi sau khi n√≥ di chuy·ªÉn
                if (solarPanel.dataset.itemId) {
                    setTimeout(() => {
                         updateConnectedWires(solarPanel.dataset.itemId);
                    }, 300); // 300ms kh·ªõp v·ªõi 'transition'
                }
            }
        }
        
        /**
         * H√ÄM SNAP: T·ª± ƒë·ªông g·∫Øn C√¥ng t·∫Øc (switch) v√†o Ng√¥i nh√† (house)
         */
        function snapSwitchToHouse() {
            const house = document.querySelector('#model-a [data-tool="house"]');
            const mainSwitch = document.querySelector('#model-a [data-tool="switch"]');

            if (house && mainSwitch) {
                const houseTop = parseFloat(house.style.top);
                const houseLeft = parseFloat(house.style.left);
                const houseHeight = parseFloat(house.style.height); // 320px
                const houseWidth = parseFloat(house.style.width); // 320px

                const switchWidth = parseFloat(mainSwitch.style.width); // 80px
                const switchHeight = parseFloat(mainSwitch.style.height); // 80px
                
                // C·ª≠a (theo SVG): x="40", y="60", width="20", height="35"
                // (T·ª∑ l·ªá 0-100)
                const doorLeftRatio = 40 / 100;
                const doorTopRatio = 60 / 100;
                const doorHeightRatio = 35 / 100;
                const doorWidthRatio = 20 / 100; // Th√™m chi·ªÅu r·ªông c·ª≠a
                
                // V·ªã tr√≠ c·ª≠a (ƒë√£ scale)
                const doorLeftPx = houseLeft + (houseWidth * doorLeftRatio);
                const doorTopPx = houseTop + (houseHeight * doorTopRatio);
                const doorHeightPx = houseHeight * doorHeightRatio;
                const doorWidthPx = houseWidth * doorWidthRatio; // Th√™m chi·ªÅu r·ªông c·ª≠a
                
                // C·∫¨P NH·∫¨T: "gi·ªØa m√©p ph·∫£i c√°nh c·ª≠a"
                let targetX = doorLeftPx + doorWidthPx + 5; // 5px b√™n ph·∫£i c·ª≠a
                let targetY = doorTopPx + (doorHeightPx / 2) - (switchHeight / 2); // Gi·ªØa c·ª≠a (chi·ªÅu d·ªçc)

                // Gi·ªõi h·∫°n
                targetX = Math.max(0, Math.min(targetX, dropZone.clientWidth - switchWidth));
                targetY = Math.max(0, Math.min(targetY, dropZone.clientHeight - switchHeight));

                mainSwitch.style.left = `${targetX}px`;
                mainSwitch.style.top = `${targetY}px`;

                if (mainSwitch.dataset.itemId) {
                    setTimeout(() => {
                         updateConnectedWires(mainSwitch.dataset.itemId);
                    }, 300);
                }
            }
        }
        
        /**
         * H√ÄM SNAP: T·ª± ƒë·ªông g·∫Øn B√≥ng ƒë√®n (light-bulb) v√†o Ng√¥i nh√† (house)
         */
        function snapLightBulbToHouse() {
            const house = document.querySelector('#model-a [data-tool="house"]');
            const lightBulb = document.querySelector('#model-a [data-tool="light-bulb"]');

            if (house && lightBulb) {
                const houseTop = parseFloat(house.style.top);
                const houseLeft = parseFloat(house.style.left);
                const houseHeight = parseFloat(house.style.height); // 320px
                const houseWidth = parseFloat(house.style.width); // 320px

                const bulbWidth = parseFloat(lightBulb.style.width); // 80px
                const bulbHeight = parseFloat(lightBulb.style.height); // 80px
                
                // C·ª≠a (theo SVG): x="40", y="60", width="20"
                const doorLeftRatio = 40 / 100;
                const doorTopRatio = 60 / 100;
                const doorWidthRatio = 20 / 100;
                
                // V·ªã tr√≠ c·ª≠a (ƒë√£ scale)
                const doorLeftPx = houseLeft + (houseWidth * doorLeftRatio);
                const doorTopPx = houseTop + (houseHeight * doorTopRatio);
                const doorWidthPx = houseWidth * doorWidthRatio;

                // "ph√≠a tr√™n c√°nh c·ª≠a"
                let targetX = doorLeftPx + (doorWidthPx / 2) - (bulbWidth / 2); // Gi·ªØa c·ª≠a (chi·ªÅu ngang)
                let targetY = doorTopPx - bulbHeight - 5; // 5px ph√≠a tr√™n c·ª≠a

                // Gi·ªõi h·∫°n
                targetX = Math.max(0, Math.min(targetX, dropZone.clientWidth - bulbWidth));
                targetY = Math.max(0, Math.min(targetY, dropZone.clientHeight - bulbHeight));

                lightBulb.style.left = `${targetX}px`;
                lightBulb.style.top = `${targetY}px`;

                if (lightBulb.dataset.itemId) {
                    setTimeout(() => {
                         updateConnectedWires(lightBulb.dataset.itemId);
                    }, 300);
                }
            }
        }

        // === TH√äM M·ªöI: Logic g·ªçi Gemini API ===
        /**
         * G·ªçi Gemini API ƒë·ªÉ l·∫•y c√¢u tr·∫£ l·ªùi
         * @param {string} userQuery C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
         */
        async function callGeminiAPI(userQuery) {
            const apiKey = "AIzaSyCpMBwDCCrIT4nhprDdxjQ69NSIoGyKoEU"; // API key s·∫Ω ƒë∆∞·ª£c cung c·∫•p b·ªüi m√¥i tr∆∞·ªùng Canvas
            const apiUrlText = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            // Th√™m ng·ªØ c·∫£nh v·ªÅ game v√†o prompt
            const systemPrompt = `B·∫°n l√† m·ªôt AI tr·ª£ gi√∫p trong tr√≤ ch∆°i m√¥ ph·ªèng nƒÉng l∆∞·ª£ng xanh Green Energy Game. Tr·∫£ l·ªùi ng·∫Øn g·ªçn c√°c c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng li√™n quan ƒë·∫øn nƒÉng l∆∞·ª£ng m·∫∑t tr·ªùi, nƒÉng l∆∞·ª£ng gi√≥, c√°ch ho·∫°t ƒë·ªông c·ªßa m·∫°ch ƒëi·ªán trong game n√†y. Game c√≥ c√°c c√¥ng c·ª•: M·∫∑t tr·ªùi, M√¢y, Pin m·∫∑t tr·ªùi, Gi√≥, Tua-bin gi√≥, T·ªß ƒëi·ªán, D√¢y d·∫´n, C√¥ng t·∫Øc, B√≥ng ƒë√®n, Ng√¥i nh√†.`;

            const payloadText = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            // Hi·ªÉn th·ªã loading
            aiExplanationElement.textContent = "Bot ƒëang suy nghƒ©...";
            aiLoader.classList.remove('hidden');
            aiSendButton.disabled = true;
            aiQuestionInput.disabled = true;

            try {
                // G·ªçi API t·∫°o vƒÉn b·∫£n
                const responseText = await fetch(apiUrlText, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payloadText)
                });

                if (!responseText.ok) {
                    throw new Error(`Text API call failed with status: ${responseText.status}`);
                }

                const resultText = await responseText.json();
                console.log("Gemini Text API Response:", resultText); // Debug log

                const candidate = resultText.candidates?.[0];
                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const textToSpeak = candidate.content.parts[0].text;
                    updateAIExplanation(textToSpeak); // Hi·ªÉn th·ªã c√¢u tr·∫£ l·ªùi
                    await callTTSAPI(textToSpeak); // G·ªçi TTS ƒë·ªÉ ƒë·ªçc c√¢u tr·∫£ l·ªùi
                } else {
                     console.error("Unexpected Text API response structure:", resultText);
                     updateAIExplanation("Xin l·ªói, t√¥i g·∫∑p ch√∫t tr·ª•c tr·∫∑c khi x·ª≠ l√Ω y√™u c·∫ßu.");
                }

            } catch (error) {
                console.error("Error calling Gemini API:", error);
                updateAIExplanation("ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi v·ªõi AI. Vui l√≤ng th·ª≠ l·∫°i sau.");
            } finally {
                // ·∫®n loading
                aiLoader.classList.add('hidden');
                aiSendButton.disabled = false;
                aiQuestionInput.disabled = false;
            }
        }

        /**
         * TH√äM M·ªöI: G·ªçi Gemini TTS API
         * @param {string} textToSpeak VƒÉn b·∫£n c·∫ßn ƒë·ªçc
         */
        async function callTTSAPI(textToSpeak) {
             if (!textToSpeak) {
                 console.warn("TTS called with empty text.");
                 return;
             }
            const apiKey = "AIzaSyCpMBwDCCrIT4nhprDdxjQ69NSIoGyKoEU"; // API key s·∫Ω ƒë∆∞·ª£c cung c·∫•p b·ªüi m√¥i tr∆∞·ªùng Canvas
            const apiUrlTTS = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

             // C·ªë g·∫Øng d·ª´ng ph√°t √¢m thanh hi·ªán t·∫°i n·∫øu c√≥
             aiAudioElement.pause();
             aiAudioElement.currentTime = 0;


            const payloadTTS = {
                contents: [{
                    parts: [{ text: textToSpeak }] // S·ª≠ d·ª•ng vƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c t·∫°o
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            // Ch·ªçn gi·ªçng ƒë·ªçc, c√≥ th·ªÉ ƒë·ªÉ tr·ªëng ƒë·ªÉ t·ª± ƒë·ªông ho·∫∑c ch·ªçn gi·ªçng c·ª• th·ªÉ
                            // prebuiltVoiceConfig: { voiceName: "Kore" } // V√≠ d·ª•
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const responseTTS = await fetch(apiUrlTTS, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payloadTTS)
                });

                if (!responseTTS.ok) {
                    throw new Error(`TTS API call failed with status: ${responseTTS.status}`);
                }

                const resultTTS = await responseTTS.json();
                console.log("Gemini TTS API Response:", resultTTS); // Debug log

                // S·ª¨A L·ªñI: Ki·ªÉm tra c·∫•u tr√∫c response k·ªπ h∆°n
                const candidate = resultTTS?.candidates?.[0];
                 if (candidate && candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
                     const part = candidate.content.parts[0];
                     // S·ª¨A L·ªñI: Ki·ªÉm tra xem 'part' v√† 'inlineData' c√≥ t·ªìn t·∫°i kh√¥ng
                     const audioData = part?.inlineData?.data;
                     const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        // MimeType th∆∞·ªùng l√† audio/L16;rate=24000
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000; // M·∫∑c ƒë·ªãnh 24kHz

                        const pcmData = base64ToArrayBuffer(audioData);
                        // API tr·∫£ v·ªÅ signed PCM16
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        // Ki·ªÉm tra n·∫øu wavBlob h·ª£p l·ªá
                        if (!wavBlob) {
                            console.error("Failed to create WAV blob.");
                            return;
                        }
                        const audioUrl = URL.createObjectURL(wavBlob);

                        // S·ª¨A L·ªñI: D·ª´ng audio c≈© tr∆∞·ªõc khi ƒë·∫∑t src m·ªõi
                        aiAudioElement.pause();
                        aiAudioElement.currentTime = 0;
                        aiAudioElement.src = audioUrl;

                        // S·ª≠ d·ª•ng setTimeout ƒë·ªÉ ƒë·∫£m b·∫£o src ƒë∆∞·ª£c load tr∆∞·ªõc khi play
                        setTimeout(() => {
                             aiAudioElement.play().catch(e => console.error("Audio playback failed:", e));
                        }, 100); // Delay 100ms

                    } else {
                        console.error("TTS API response missing audio data or mimeType:", part);
                        // Kh√¥ng c·∫ßn b√°o l·ªói cho ng∆∞·ªùi d√πng n·∫øu ch·ªâ TTS th·∫•t b·∫°i
                    }
                } else {
                     console.error("Unexpected TTS API response structure (missing content/parts/inlineData):", resultTTS);
                     // Kh√¥ng c·∫ßn b√°o l·ªói cho ng∆∞·ªùi d√πng n·∫øu ch·ªâ TTS th·∫•t b·∫°i
                }

            } catch (error) {
                 console.error("Error calling TTS API:", error);
                 // Kh√¥ng c·∫ßn b√°o l·ªói cho ng∆∞·ªùi d√πng n·∫øu ch·ªâ TTS th·∫•t b·∫°i
            }
        }
        
        // === TH√äM M·ªöI: H√ÄM UNDO/RESET ===

        /**
         * L∆∞u tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa m√†n h√¨nh A v√†o history stack
         */
        function saveState() {
            // L·∫•y HTML c·ªßa t·∫•t c·∫£ items v√† wires
            // D√πng innerHTML l√† c√°ch ƒë∆°n gi·∫£n nh·∫•t ƒë·ªÉ serialize
            const itemsHTML = dropZone.innerHTML; 
            const wiresHTML = wireLayer.innerHTML;
            
            // L·∫•y class c·ªßa n·ªÅn (ƒë·ªÉ l∆∞u tr·∫°ng th√°i m√¢y che)
            const backgroundState = dropZone.className;
            
            // Ch·ªâ l∆∞u nh·ªØng ph·∫ßn c·∫ßn thi·∫øt (b·ªè qua bot v√† ti√™u ƒë·ªÅ)
            const items = Array.from(dropZone.querySelectorAll('.cloned-item')).map(el => el.outerHTML);
            const wires = Array.from(wireLayer.querySelectorAll('.permanent-wire')).map(el => el.outerHTML);
            
            historyStack.push({
                items: items.join(''),
                wires: wires.join(''),
                background: backgroundState
            });
            
            // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc history
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift(); // X√≥a tr·∫°ng th√°i c≈© nh·∫•t
            }
        }

        /**
         * Quay l·∫°i tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥
         */
        function undo() {
            if (historyStack.length < 2) { // C·∫ßn √≠t nh·∫•t 2 tr·∫°ng th√°i (hi·ªán t·∫°i v√† tr∆∞·ªõc ƒë√≥)
                const msg = "Kh√¥ng th·ªÉ ho√†n t√°c th√™m.";
                updateAIExplanation(msg);
                callTTSAPI(msg);
                return;
            }
            
            // X√≥a tr·∫°ng th√°i hi·ªán t·∫°i
            historyStack.pop(); 
            // L·∫•y tr·∫°ng th√°i ngay tr∆∞·ªõc ƒë√≥
            const lastState = historyStack[historyStack.length - 1]; 
            
            // X√≥a b·∫£ng hi·ªán t·∫°i
            dropZone.querySelectorAll('.cloned-item').forEach(item => item.remove());
            wireLayer.querySelectorAll('.permanent-wire').forEach(wire => wire.remove());
            
            // Kh√¥i ph·ª•c
            dropZone.className = lastState.background;
            dropZone.insertAdjacentHTML('beforeend', lastState.items);
            wireLayer.insertAdjacentHTML('beforeend', lastState.wires);
            
            // C·∫≠p nh·∫≠t l·∫°i to√†n b·ªô m√¥ ph·ªèng
            updateAllSimulationStates("undo"); // Th√™m context ƒë·ªÉ ch·∫∑n g·ª£i √Ω
            
            const msg = "ƒê√£ ho√†n t√°c thao t√°c.";
            updateAIExplanation(msg);
            callTTSAPI(msg);
        }

        /**
         * X√≥a to√†n b·ªô m√†n h√¨nh A v√† reset
         */
        function resetSimulation() {
            const msg = "ƒê√£ thi·∫øt l·∫≠p l·∫°i m√¥ ph·ªèng.";
            updateAIExplanation(msg);
            callTTSAPI(msg);
            
            // X√≥a items v√† wires
            dropZone.querySelectorAll('.cloned-item').forEach(item => item.remove());
            wireLayer.querySelectorAll('.permanent-wire').forEach(wire => wire.remove());
            
            // Reset history
            historyStack = []; 
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            updateAllSimulationStates("reset"); // Th√™m context ƒë·ªÉ ch·∫∑n g·ª£i √Ω
            
            // L∆∞u tr·∫°ng th√°i r·ªóng ban ƒë·∫ßu
            saveState(); 
            
            // G·ª£i √Ω sau khi reset
            setTimeout(provideNextStepGuidance, 1000); // 1s delay
        }



        // === LOGIC T∆Ø∆†NG T√ÅC CH√çNH (S·ª¨A L·ªñI TOUCH) ===

        function handleToolboxStart(e) {
            // S·ª¨A L·ªñI SCROLL: Ch·ªâ preventDefault n·∫øu target l√† tool-item
            const event = getEvent(e);
            const toolItem = event.target.closest('.tool-item');

            // N·∫øu kh√¥ng nh·∫•n v√†o item (nh·∫•n v√†o n·ªÅn panel), cho ph√©p scroll
            if (!toolItem) {
                isPotentialDrag = false;
                return; 
            }
            
            // N·∫øu nh·∫•n v√†o item, ngƒÉn scroll v√† b·∫Øt ƒë·∫ßu logic k√©o
            e.preventDefault(); 
            
            // Ki·ªÉm tra xem item c√≥ b·ªã c·∫•m kh√¥ng
            if (toolItem.classList.contains('tool-prohibited')) {
                // B√°o hi·ªáu (v√≠ d·ª•: rung nh·∫π) v√† kh√¥ng cho k√©o
                toolItem.style.transform = 'scale(1.1) rotate(-5deg)';
                setTimeout(() => toolItem.style.transform = 'scale(1)', 200);
                isPotentialDrag = false; // H·ªßy k√©o
                return; // ƒê√£ t·ªìn t·∫°i, kh√¥ng cho k√©o
            }


            isPotentialDrag = true; // B·∫Øt ƒë·∫ßu nh·∫•n chu·ªôt/ch·∫°m
            touchStartX = event.clientX;
            touchStartY = event.clientY;
            
            // KI·ªÇM TRA CH·∫æ ƒê·ªò N·ªêI D√ÇY (CLICK)
            if (toolItem.dataset.tool === 'wire') {
                isWiringMode = !isWiringMode; // Chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i
                
                if (isWiringMode) {
                    document.body.classList.add('wiring-mode');
                    wireToolCell.classList.add('active-tool');
                    updateAIExplanation("Ch·∫ø ƒë·ªô n·ªëi d√¢y B·∫¨T. Nh·∫•n v√†o t·ªß ƒëi·ªán, pin, tua-bin ho·∫∑c ƒë√®n ƒë·ªÉ b·∫Øt ƒë·∫ßu.");
                } else {
                    document.body.classList.remove('wiring-mode');
                    wireToolCell.classList.remove('active-tool');
                    updateAIExplanation("Ch·∫ø ƒë·ªô n·ªëi d√¢y T·∫ÆT.");
                }
                isPotentialDrag = false; // ƒê√¢y l√† 1 c√∫ click, kh√¥ng ph·∫£i drag
                return; // KH√îNG TH·ª∞C HI·ªÜN K√âO TH·∫¢
            }
            
            // T·∫†O B·∫¢N SAO ƒê·ªÇ K√âO (Ch·ªâ khi KH√îNG ·ªü ch·∫ø ƒë·ªô n·ªëi d√¢y)
            if (!isWiringMode) {
                // Logic ki·ªÉm tra ƒë·ªôc quy·ªÅn ƒë√£ ƒë∆∞·ª£c d·ªùi l√™n tr√™n
            
                draggedItemCopy = toolItem.cloneNode(true); 
                draggedItemCopy.classList.add('dragging', 'cloned-item');
                draggedItemCopy.classList.remove('tool-item', 'tool-prohibited'); // X√≥a class c·∫•m kh·ªèi b·∫£n sao

                const rect = toolItem.getBoundingClientRect();
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;

                draggedItemCopy.style.left = `${event.clientX - offsetX}px`;
                draggedItemCopy.style.top = `${event.clientY - offsetY}px`;

                document.body.appendChild(draggedItemCopy);
            }
        }
        
        function handleDropZoneStart(e) {
             const event = getEvent(e); // Chu·∫©n h√≥a
            isPotentialDrag = true; // B·∫Øt ƒë·∫ßu nh·∫•n chu·ªôt
            touchStartX = event.clientX;
            touchStartY = event.clientY;
            
            const targetItem = event.target.closest('.cloned-item');

            // TR∆Ø·ªúNG H·ª¢P 1: ƒêANG ·ªû CH·∫æ ƒê·ªò N·ªêI D√ÇY
            if (isWiringMode) {
                e.preventDefault();
                isPotentialDrag = false; // N·ªëi d√¢y kh√¥ng ph·∫£i l√† k√©o
                // Ph·∫£i c√≥ item V√Ä item ƒë√≥ l√† m·ªôt "ƒë·∫ßu n·ªëi" h·ª£p l·ªá
                if (targetItem && wiringParticipants.includes(targetItem.dataset.tool)) {
                    // B·∫Øt ƒë·∫ßu v·∫Ω d√¢y
                    wiringStartItem = targetItem;
                    const startPos = getCenter(wiringStartItem); 
                    
                    // T·∫°o d√¢y t·∫°m th·ªùi
                    tempWire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempWire.setAttribute('id', 'temp-wire');
                    tempWire.setAttribute('d', `M ${startPos.x} ${startPos.y} L ${startPos.x} ${startPos.y}`);
                    wireLayer.appendChild(tempWire);
                    const explanation = `B·∫Øt ƒë·∫ßu n·ªëi d√¢y t·ª´ ${wiringStartItem.title}. K√©o ƒë·∫øn thi·∫øt b·ªã kh√°c...`;
                    updateAIExplanation(explanation);
                    // callTTSAPI(explanation); // C√≥ th·ªÉ th√™m n·∫øu mu·ªën
                }
                return; 
            }
            
            // TR∆Ø·ªúNG H·ª¢P 2: DI CHUY·ªÇN C√îNG C·ª§ ƒê√É C√ì
            if (targetItem) {
                // S·ª¨A L·ªñI CLICK: Lu√¥n preventDefault ƒë·ªÉ k√©o/ch·∫°m ho·∫°t ƒë·ªông
                e.preventDefault(); // NgƒÉn ch·∫∑n text selection
                
                draggedItem = targetItem;
                // S·ª¨A L·ªñI CLICK: ƒê·∫∑t z-index ngay l·∫≠p t·ª©c, nh∆∞ng ch∆∞a add 'dragging'
                // 'dragging' s·∫Ω ƒë∆∞·ª£c th√™m trong 'mousemove' n·∫øu chu·ªôt th·ª±c s·ª± di chuy·ªÉn
                draggedItem.style.zIndex = 1001; 
                
                const rect = draggedItem.getBoundingClientRect();
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;
            }
        }

        // 4. DI CHUY·ªÇN CHU·ªòT (Global)
        function handleDragMove(e) {
            // S·ª¨A L·ªñI SCROLL: Ch·ªâ preventDefault N·∫æU ƒëang k√©o/n·ªëi d√¢y
            if (isDragging || wiringStartItem) {
                e.preventDefault(); 
            }
            
            const event = getEvent(e); // Chu·∫©n h√≥a
            
            // S·ª¨A L·ªñI CLICK: N·∫øu ƒëang nh·∫•n chu·ªôt (potentialDrag), v√† chu·ªôt di chuy·ªÉn -> x√°c nh·∫≠n l√† K√âO
            if (isPotentialDrag && (draggedItem || draggedItemCopy)) {
                // Ch·ªâ ƒë·∫∑t isDragging n·∫øu th·ª±c s·ª± di chuy·ªÉn m·ªôt kho·∫£ng nh·ªè
                if (Math.abs(event.clientX - touchStartX) > 5 || Math.abs(event.clientY - touchStartY) > 5) {
                     isDragging = true; 
                    // Th√™m class dragging khi b·∫Øt ƒë·∫ßu k√©o
                    if(draggedItem && !draggedItem.classList.contains('dragging')) draggedItem.classList.add('dragging');
                    if(draggedItemCopy && !draggedItemCopy.classList.contains('dragging')) draggedItemCopy.classList.add('dragging'); // Th√™m cho clone
                }
            }

            const mousePos = getMousePos(event); // S·ª¨A: D√πng event

            // A. ƒêang k√©o (di chuy·ªÉn) item
            if (draggedItem && isDragging) {
                let x = mousePos.x - offsetX;
                let y = mousePos.y - offsetY;

                x = Math.max(0, Math.min(x, dropZone.clientWidth - draggedItem.clientWidth));
                y = Math.max(0, Math.min(y, dropZone.clientHeight - draggedItem.clientHeight));
                
                draggedItem.style.left = `${x}px`;
                draggedItem.style.top = `${y}px`;

                // C·∫¨P NH·∫¨T D√ÇY D·∫™N (LU√îN LU√îN)
                if (draggedItem.dataset.itemId) {
                    updateConnectedWires(draggedItem.dataset.itemId);
                }
                
                // C·∫¨P NH·∫¨T M√ÇY CHE/M·∫∂T TR·ªúI (N·∫æU ƒêANG K√âO M√ÇY/M·∫∂T TR·ªúI)
                const toolType = draggedItem.dataset.tool;
                if (toolType === 'cloud' || toolType === 'sun') {
                    updateAllSimulationStates("drag"); // Th√™m context
                }
            }
            // B. ƒêang k√©o (sao ch√©p) item m·ªõi
            else if (draggedItemCopy && isDragging) {
                draggedItemCopy.style.left = `${event.clientX - offsetX}px`;
                draggedItemCopy.style.top = `${event.clientY - offsetY}px`;
            }
            // C. ƒêang k√©o (n·ªëi d√¢y)
            else if (wiringStartItem && tempWire) {
                const startPos = getCenter(wiringStartItem);
                // V·∫Ω ƒë∆∞·ªùng cong m∆∞·ª£t theo v·ªã tr√≠ chu·ªôt (cho m·ª•c ƒë√≠ch xem tr∆∞·ªõc)
                tempWire.setAttribute('d', `M ${startPos.x} ${startPos.y} Q ${startPos.x} ${mousePos.y} ${mousePos.x} ${mousePos.y}`);
            }
        }

        // 5. NH·∫¢ CHU·ªòT (Global)
        function handleDragEnd(e) {
            let stateChanged = false; // C·ªù theo d√µi
            let actionContext = null; // Theo d√µi h√†nh ƒë·ªông
            
            // S·ª¨A: L·∫•y clientX/Y t·ª´ s·ª± ki·ªán touch (changedTouches) n·∫øu c√≥
            const event = e.changedTouches ? e.changedTouches[0] : e;

            const dropZoneRect = dropZone.getBoundingClientRect();
            const toolBoxRect = toolBox.getBoundingClientRect();

            const isOverDropZone = event.clientX >= dropZoneRect.left && event.clientX <= dropZoneRect.right &&
                                 event.clientY >= dropZoneRect.top && event.clientY <= dropZoneRect.bottom;
            
            const isOverToolBox = event.clientX >= toolBoxRect.left && event.clientX <= toolBoxRect.right &&
                                event.clientY >= toolBoxRect.top && event.clientY <= toolBoxRect.bottom;

            // TR∆Ø·ªúNG H·ª¢P 1: K·∫æT TH√öC N·ªêI D√ÇY
            if (isWiringMode && wiringStartItem) {
                // S·ª¨A: L·∫•y ph·∫ßn t·ª≠ t·∫°i ƒëi·ªÉm ch·∫°m/click cu·ªëi c√πng
                const endElement = document.elementFromPoint(event.clientX, event.clientY);
                const endItem = endElement ? endElement.closest('.cloned-item') : null;

                const startType = wiringStartItem.dataset.tool;
                const endType = endItem ? endItem.dataset.tool : null;
                let explanation = "";

                // Ki·ªÉm tra m·ª•c ti√™u h·ª£p l·ªá: Ph·∫£i l√† ƒë·∫ßu n·ªëi h·ª£p l·ªá, kh√¥ng ph·∫£i ch√≠nh n√≥
                if (endItem && endItem !== wiringStartItem && wiringParticipants.includes(endType)) 
                {
                    createPermanentWire(wiringStartItem, endItem);
                    explanation = `ƒê√£ n·ªëi d√¢y gi·ªØa ${wiringStartItem.title} v√† ${endItem.title}.`;
                    stateChanged = true;
                    actionContext = "wire";
                    // Th√¥ng b√°o n·ªëi d√¢y th√†nh c√¥ng ƒë√£ c√≥ trong createPermanentWire
                } else {
                     explanation = "N·ªëi d√¢y kh√¥ng th√†nh c√¥ng. H√£y k√©o t·ª´ m·ªôt thi·∫øt b·ªã ƒë·∫øn m·ªôt thi·∫øt b·ªã kh√°c.";
                }
                updateAIExplanation(explanation);
                callTTSAPI(explanation); // G·ªçi TTS

                // Reset tr·∫°ng th√°i n·ªëi d√¢y
                if(tempWire) tempWire.remove();
                tempWire = null;
                wiringStartItem = null;
                
                // T·∫ÆT CH·∫æ ƒê·ªò N·ªêI D√ÇY V√Ä HI·ªÇN TH·ªä
                isWiringMode = false;
                document.body.classList.remove('wiring-mode');
                wireToolCell.classList.remove('active-tool');
                
                updateAllSimulationStates(actionContext); // C·∫≠p nh·∫≠t l·∫°i to√†n b·ªô sau khi n·ªëi d√¢y (ho·∫∑c kh√¥ng)
                // return; // Kh√¥ng return v·ªôi, ƒë·ªÉ reset isDragging
            }
            
            // TR∆Ø·ªúNG H·ª¢P 2: TH·∫¢ C√îNG C·ª§ M·ªöI (CLONE)
            else if (draggedItemCopy) {
                draggedItemCopy.classList.remove('dragging');
                
                // Th√™m ki·ªÉm tra
                if (draggedItemCopy.parentNode === document.body) {
                    document.body.removeChild(draggedItemCopy); 
                }
                
                const newToolType = draggedItemCopy.dataset.tool;
                const toolTitle = draggedItemCopy.title; // L·∫•y title ƒë·ªÉ d√πng cho AI Bot
                let explanation = "";
                
                if (isOverDropZone && isDragging) { // Ch·ªâ th·∫£ n·∫øu th·ª±c s·ª± k√©o
                    const mousePos = getMousePos(event); // S·ª¨A: D√πng event
                    
                    let x = mousePos.x - offsetX;
                    let y = mousePos.y - offsetY;

                    // C·∫¨P NH·∫¨T LOGIC PH√ìNG TO CHO RESPONSIVE
                    const isMobile = (window.innerWidth < 768);
                    const baseSize = isMobile ? 60 : 80;
                    let scaleFactor = 1;

                    if (newToolType === 'house') {
                        scaleFactor = isMobile ? 3 : 4; // Gi·∫£m scale tr√™n mobile
                    } else if (newToolType === 'wind-turbine') {
                        scaleFactor = isMobile ? 2.5 : 3; // Gi·∫£m scale tr√™n mobile
                    } else if (newToolType === 'solar-panel') { 
                        scaleFactor = isMobile ? 1.5 : 2; // Gi·∫£m scale tr√™n mobile
                    }
                    
                    const newWidth = baseSize * scaleFactor;
                    const newHeight = baseSize * scaleFactor;

                    // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ th·∫£ d·ª±a tr√™n k√≠ch th∆∞·ªõc m·ªõi (tr√°nh tr√†n l·ªÅ)
                    x = Math.max(0, Math.min(x, dropZone.clientWidth - newWidth));
                    y = Math.max(0, Math.min(y, dropZone.clientHeight - newHeight));
                    
                    draggedItemCopy.style.left = `${x}px`;
                    draggedItemCopy.style.top = `${y}px`;
                    draggedItemCopy.style.width = `${newWidth}px`; 
                    draggedItemCopy.style.height = `${newHeight}px`;
                    
                    // S·ª¨A ƒê·ªîI: ƒê·∫∑t z-index
                    if (newToolType === 'house') {
                        draggedItemCopy.style.zIndex = 5; // D∆∞·ªõi c√πng
                    } else if (newToolType === 'solar-panel') {
                        draggedItemCopy.style.zIndex = 8; // Tr√™n nh√†, d∆∞·ªõi d√¢y
                    } else {
                        draggedItemCopy.style.zIndex = 20; // M·∫∑c ƒë·ªãnh
                    }

                    // G√°n ID duy nh·∫•t cho item m·ªõi (ƒë·ªÉ qu·∫£n l√Ω d√¢y d·∫´n sau n√†y)
                    draggedItemCopy.dataset.itemId = generateUUID();
                    
                    dropZone.appendChild(draggedItemCopy);
                    
                    // B·ªé GI·∫¢I TH√çCH KHI ƒê·∫∂T C√îNG C·ª§
                    // explanation = `B·∫°n v·ª´a ƒë·∫∑t ${toolTitle}.`;
                    // updateAIExplanation(explanation);
                    // callTTSAPI(explanation); // G·ªçi TTS
                    actionContext = "drop"; // ƒê√°nh d·∫•u l√† h√†nh ƒë·ªông th·∫£

                    // C·∫¨P NH·∫¨T: G·ªçi h√†m snap T·ªß ƒëi·ªán/Pin m·∫∑t tr·ªùi
                    updateAllSnapPositions();
                    
                    // C·∫¨P NH·∫¨T TO√ÄN B·ªò M√î PH·ªéNG
                    updateAllSimulationStates(actionContext);
                    stateChanged = true;
                } else {
                    // Ch·ªâ hi·ªÉn th·ªã n·∫øu kh√¥ng ph·∫£i l√† click v√†o tool c·∫•m
                     if(isDragging) {
                         explanation = "H√£y th·∫£ c√¥ng c·ª• v√†o khu v·ª±c b√™n tr√°i.";
                         updateAIExplanation(explanation);
                         // callTTSAPI(explanation); // C√≥ th·ªÉ kh√¥ng c·∫ßn ƒë·ªçc l·ªói n√†y
                     }
                }
                draggedItemCopy = null;
            }
            
            // TR∆Ø·ªúNG H·ª¢P 3: TH·∫¢ C√îNG C·ª§ ƒêANG DI CHUY·ªÇN (MOVE/DELETE)
            else if (draggedItem) {
                draggedItem.classList.remove('dragging'); // X√≥a class dragging
                let explanation = "";
                
                if (isOverToolBox && isDragging) { // Ch·ªâ x√≥a n·∫øu th·ª±c s·ª± k√©o
                    const removedItemId = draggedItem.dataset.itemId;
                    const toolTitle = draggedItem.title; // L·∫•y title cho AI Bot
                    
                    // X√ìA D√ÇY D·∫™N LI√äN QUAN
                    if (removedItemId) {
                        removeWires(removedItemId);
                    }

                    draggedItem.remove(); 
                    // TH√äM M·ªöI: AI Bot gi·∫£i th√≠ch
                    explanation = `B·∫°n ƒë√£ x√≥a ${toolTitle}.`;
                    updateAIExplanation(explanation);
                     callTTSAPI(explanation); // G·ªçi TTS
                    stateChanged = true;
                    actionContext = "delete";
                    
                } else if (isDragging) { // Ch·ªâ th·ª±c hi·ªán logic th·∫£ n·∫øu th·ª±c s·ª± k√©o
                    // Reset z-index ch√≠nh x√°c khi th·∫£
                    if (draggedItem.dataset.tool === 'house') {
                        draggedItem.style.zIndex = 5; 
                    } else if (draggedItem.dataset.tool === 'solar-panel') {
                        draggedItem.style.zIndex = 8;
                    } else {
                        draggedItem.style.zIndex = 20; 
                    }

                    // C·∫≠p nh·∫≠t d√¢y d·∫´n l·∫ßn cu·ªëi khi th·∫£
                    if (draggedItem.dataset.itemId) {
                        updateConnectedWires(draggedItem.dataset.itemId);
                    }
                    
                    // C·∫¨P NH·∫¨T: G·ªçi h√†m snap khi di chuy·ªÉn Ng√¥i nh√†
                    if (draggedItem.dataset.tool === 'house') {
                        updateAllSnapPositions();
                    }
                    stateChanged = true; // Coi di chuy·ªÉn l√† m·ªôt thay ƒë·ªïi
                    actionContext = "move";
                    // B·ªé GI·∫¢I TH√çCH KHI DI CHUY·ªÇN
                    // updateAIExplanation(`B·∫°n ƒë√£ di chuy·ªÉn ${draggedItem.title}.`);
                
                // S·ª¨A L·ªñI CLICK: X·ª≠ l√Ω click c√¥ng t·∫Øc ·ªü ƒë√¢y
                } else if (!isDragging && draggedItem.dataset.tool === 'switch') {
                    // ƒê√¢y l√† m·ªôt c√∫ CLICK (kh√¥ng ph·∫£i k√©o) l√™n c√¥ng t·∫Øc
                    draggedItem.classList.toggle('switch-on');
                    explanation = draggedItem.classList.contains('switch-on') ? "C√¥ng t·∫Øc ƒë√£ ƒë∆∞·ª£c b·∫≠t." : "C√¥ng t·∫Øc ƒë√£ ƒë∆∞·ª£c t·∫Øt.";
                    updateAIExplanation(explanation);
                    callTTSAPI(explanation); // G·ªçi TTS
                    
                    stateChanged = true;
                    actionContext = "switch";
                }
                
                // C·∫¨P NH·∫¨T TO√ÄN B·ªò M√î PH·ªéNG (sau khi x√≥a ho·∫∑c th·∫£)
                updateAllSimulationStates(actionContext);
                draggedItem = null; 
            }
            
            // S·ª¨A L·ªñI CLICK: Reset tr·∫°ng th√°i k√©o
            isDragging = false;
            isPotentialDrag = false;

            // L∆ØU TR·∫†NG TH√ÅI V√Ä ƒê∆ØA RA G·ª¢I √ù
            if (stateChanged) {
                saveState();
                 // Ch·ªâ ƒë∆∞a ra g·ª£i √Ω n·∫øu h√†nh ƒë·ªông kh√¥ng ph·∫£i l√† "move"
                if (actionContext !== "move") {
                     setTimeout(provideNextStepGuidance, 1500); 
                }
            }
        }
        
        // S·ª¨A L·ªñI: Th√™m c√°c h√†m x·ª≠ l√Ω s·ª± ki·ªán Touch V√Ä Mouse
        
        // Mouse Events
        toolBox.addEventListener('mousedown', handleToolboxStart);
        dropZone.addEventListener('mousedown', handleDropZoneStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // Touch Events
        toolBox.addEventListener('touchstart', handleToolboxStart, { passive: false });
        dropZone.addEventListener('touchstart', handleDropZoneStart, { passive: false });
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);

        
        // C·∫¨P NH·∫¨T: X·ª≠ l√Ω s·ª± ki·ªán nh·∫•n n√∫t G·ª≠i c·ªßa AI Bot (G·ªçi Gemini)
        aiSendButton.addEventListener('click', () => {
            const question = aiQuestionInput.value.trim();
            if (question && !aiSendButton.disabled) { // Ki·ªÉm tra n√∫t c√≥ b·ªã disable kh√¥ng
                callGeminiAPI(question); // G·ªçi API
                aiQuestionInput.value = ''; // X√≥a input
            }
        });
        // Cho ph√©p g·ª≠i b·∫±ng Enter
        aiQuestionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !aiSendButton.disabled) {
                aiSendButton.click();
            }
        });

        // TH√äM M·ªöI: Listeners cho Reset v√† Undo
        resetButton.addEventListener('click', resetSimulation);
        undoButton.addEventListener('click', undo);

        
        // KH·ªûI CH·∫†Y M√î PH·ªéNG L·∫¶N ƒê·∫¶U
        updateAllSimulationStates();
        // C·∫¨P NH·∫¨T: L·ªùi ch√†o ƒë·∫ßu v√† h∆∞·ªõng d·∫´n
        const startupMessage = "Ch√†o m·ª´ng! K√©o th·∫£ c√°c c√¥ng c·ª• t·ª´ b√™n ph·∫£i v√†o ƒë·ªÉ x√¢y d·ª±ng nh√†. B·∫Øt ƒë·∫ßu v·ªõi 'Ng√¥i nh√†' nh√©!";
        updateAIExplanation(startupMessage);
        // B·ªé G·ªåI TTS BAN ƒê·∫¶U ƒê·ªÇ TR√ÅNH L·ªñI AUTOPLAY
        // callTTSAPI(startupMessage); 
        
        // TH√äM M·ªöI: L∆∞u tr·∫°ng th√°i ban ƒë·∫ßu (r·ªóng)
        saveState(); 


    </script>
</body>
</html>


